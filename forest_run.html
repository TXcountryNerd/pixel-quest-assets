<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Forest Run Adventure</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      background: linear-gradient(to bottom, #1a472a, #2d5a3f);
      font-family: Arial, sans-serif;
      padding: 20px;
    }
    h1 {
      font-size: 2.5rem;
      background: linear-gradient(to right, #ffd700, #32cd32);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 20px;
    }
    #gameCanvas {
      border: 4px solid #daa520;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(50, 205, 50, 0.3);
    }
    .menu, .overlay {
      background: rgba(26, 71, 42, 0.95);
      padding: 30px;
      border-radius: 10px;
      border: 2px solid #ffd700;
      text-align: center;
      color: white;
    }
    .char-select { display: flex; gap: 30px; margin: 20px 0; }
    .char-btn {
      background: #2563eb;
      border: 2px solid #60a5fa;
      padding: 20px 30px;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.2s;
      color: white;
      font-weight: bold;
    }
    .char-btn:hover { transform: scale(1.05); background: #3b82f6; }
    .char-btn.girl { background: #7c3aed; border-color: #a78bfa; }
    .char-btn.girl:hover { background: #8b5cf6; }
    .char-btn img { width: 80px; height: 100px; object-fit: contain; display: block; margin: 0 auto 10px; }
    .controls { margin-top: 15px; padding-top: 15px; border-top: 1px solid #4a7c59; color: #9ca3af; font-size: 14px; }
    .controls span { color: #ffd700; }
    .tip { color: #4ade80; margin-top: 5px; }
    .warning { color: #f87171; }
    button {
      background: #16a34a;
      color: white;
      border: none;
      padding: 12px 30px;
      border-radius: 8px;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      margin: 5px;
      transition: all 0.2s;
    }
    button:hover { background: #22c55e; transform: scale(1.05); }
    button.secondary { background: #4b5563; }
    button.secondary:hover { background: #6b7280; }
    .hidden { display: none; }
    #instructions {
      margin-top: 15px;
      color: #d1d5db;
      font-size: 14px;
      background: rgba(0,0,0,0.3);
      padding: 10px 20px;
      border-radius: 8px;
    }
  </style>
</head>
<body>
  <h1>üå≤ Forest Run Adventure üå≤</h1>
  
  <div id="loadingScreen" class="menu">
    <h2>Loading...</h2>
    <div style="width: 250px; height: 20px; background: #374151; border-radius: 10px; overflow: hidden; margin: 20px auto;">
      <div id="loadingBar" style="width: 0%; height: 100%; background: linear-gradient(to right, #4ade80, #ffd700); transition: width 0.3s;"></div>
    </div>
    <p id="loadingText">0%</p>
  </div>
  
  <div id="selectScreen" class="menu hidden">
    <h2>Choose Your Hero!</h2>
    <div class="char-select">
      <button class="char-btn" onclick="selectCharacter('boy')">
        <img src="https://txcountrynerd.github.io/pixel-quest-assets/boy-transparent.png" alt="Boy">
        Boy Hero
      </button>
      <button class="char-btn girl" onclick="selectCharacter('girl')">
        <img src="https://txcountrynerd.github.io/pixel-quest-assets/girl-transparent.png" alt="Girl">
        Girl Hero
      </button>
    </div>
    <div class="controls">
      <p><span>‚Üê ‚Üí</span> Move | <span>‚Üë</span> Jump | <span>‚Üì</span> Duck</p>
      <p class="tip">Jump on enemies to defeat them!</p>
      <p class="warning">Avoid spiders at the end - they can't be killed!</p>
    </div>
  </div>
  
  <canvas id="gameCanvas" class="hidden" width="800" height="500"></canvas>
  
  <div id="gameOverScreen" class="overlay hidden">
    <h2 style="color: #ef4444; font-size: 2.5rem; margin-bottom: 15px;">GAME OVER</h2>
    <p style="margin-bottom: 20px;">Score: <span id="finalScore" style="color: #ffd700; font-weight: bold;">0</span></p>
    <button onclick="restartLevel()">Try Again</button>
    <button class="secondary" onclick="backToSelect()">New Game</button>
  </div>
  
  <div id="victoryScreen" class="overlay hidden">
    <h2 style="color: #ffd700; font-size: 2.5rem; margin-bottom: 15px;">üéâ YOU WIN! üéâ</h2>
    <p style="margin-bottom: 10px;">You escaped the forest!</p>
    <p style="margin-bottom: 20px;">Final Score: <span id="victoryScore" style="color: #ffd700; font-weight: bold;">0</span></p>
    <button onclick="backToSelect()">Play Again</button>
  </div>
  
  <div id="instructions" class="hidden">
    <span style="color: #ffd700;">‚Üê ‚Üí</span> Move | 
    <span style="color: #ffd700;">‚Üë</span> Jump | 
    <span style="color: #ffd700;">‚Üì</span> Duck | 
    <span style="color: #4ade80;">Stomp enemies from above!</span>
  </div>

<script>
// Game constants
const GAME_WIDTH = 800;
const GAME_HEIGHT = 500;
const GRAVITY = 0.6;
const JUMP_FORCE = -14;
const MOVE_SPEED = 5;
const PLAYER_WIDTH = 40;
const PLAYER_HEIGHT = 60;
const PLAYER_DUCK_HEIGHT = 35;
const GROUND_Y = 420;
const LEVEL_LENGTH = 6000;

// Sprite URLs from GitHub Pages
const SPRITE_URLS = {
  boy: 'https://txcountrynerd.github.io/pixel-quest-assets/boy-transparent.png',
  girl: 'https://txcountrynerd.github.io/pixel-quest-assets/girl-transparent.png',
  goomba: 'https://txcountrynerd.github.io/pixel-quest-assets/goomba-transparent.png',
  witch: 'https://txcountrynerd.github.io/pixel-quest-assets/witch-transparent.png',
  boss: 'https://txcountrynerd.github.io/pixel-quest-assets/boss-transparent.png'
};

// Game state
let gameState = 'loading';
let selectedCharacter = null;
let health = 5;
let score = 0;
let images = {};

let player = { x: 50, y: GROUND_Y - PLAYER_HEIGHT, vx: 0, vy: 0, onGround: false, facing: 1, ducking: false, invincible: 0 };
let platforms = [];
let pits = [];
let trees = [];
let enemies = [];
let hearts = [];
let spiders = [];
let projectiles = [];
let camera = { x: 0 };
let keys = {};
let fireworks = [];

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Load images
function loadImages() {
  const spriteKeys = Object.keys(SPRITE_URLS);
  let loaded = 0;
  
  spriteKeys.forEach(key => {
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.onload = () => {
      images[key] = img;
      loaded++;
      updateLoading(loaded, spriteKeys.length);
    };
    img.onerror = () => {
      console.error('Failed to load:', key);
      loaded++;
      updateLoading(loaded, spriteKeys.length);
    };
    img.src = SPRITE_URLS[key];
  });
}

function updateLoading(loaded, total) {
  const pct = Math.floor((loaded / total) * 100);
  document.getElementById('loadingBar').style.width = pct + '%';
  document.getElementById('loadingText').textContent = pct + '%';
  if (loaded === total) {
    setTimeout(() => {
      document.getElementById('loadingScreen').classList.add('hidden');
      document.getElementById('selectScreen').classList.remove('hidden');
      gameState = 'select';
    }, 300);
  }
}

// Level generation
function generatePlatforms() {
  const p = [];
  let x = 200;
  while (x < LEVEL_LENGTH - 800) {
    p.push({ x, y: 280 + Math.random() * 100, width: 60 + Math.random() * 80, height: 20 });
    x += 150 + Math.random() * 200;
  }
  return p;
}

function generatePits() {
  const p = [];
  let x = 400;
  while (x < LEVEL_LENGTH - 1000) {
    p.push({ x, width: 80 + Math.random() * 60 });
    x += 400 + Math.random() * 300;
  }
  return p;
}

function generateTrees() {
  const t = [];
  let x = 100;
  while (x < LEVEL_LENGTH - 200) {
    t.push({
      x, height: 150 + Math.random() * 100,
      trunkWidth: 20 + Math.random() * 15,
      canopySize: 40 + Math.random() * 30,
      layer: Math.random() > 0.5 ? 'back' : 'front'
    });
    x += 80 + Math.random() * 120;
  }
  return t;
}

function generateEnemies() {
  const e = [];
  let x = 300;
  let id = 0;
  while (x < LEVEL_LENGTH - 1200) {
    e.push({
      id: id++, x, y: GROUND_Y - 50, startX: x,
      type: Math.random() > 0.6 ? 'witch' : 'goomba',
      direction: 1, alive: true, attackCooldown: 0
    });
    const spacing = x < 2000 ? 400 : x < 4000 ? 300 : 200;
    x += spacing + Math.random() * 200;
  }
  return e;
}

function generateHearts() {
  const h = [];
  let x = 600;
  while (x < LEVEL_LENGTH - 1000) {
    h.push({ x, y: 250 + Math.random() * 100, collected: false });
    x += 800 + Math.random() * 400;
  }
  return h;
}

function generateSpiders() {
  const s = [];
  const startX = LEVEL_LENGTH - 600;
  for (let i = 0; i < 5; i++) {
    const baseY = 100 + Math.random() * 50;
    s.push({ x: startX + i * 100, y: baseY, baseY, direction: i % 2 === 0 ? 1 : -1, speed: 1.5 + Math.random() * 1.5 });
  }
  return s;
}

function initLevel() {
  player = { x: 50, y: GROUND_Y - PLAYER_HEIGHT, vx: 0, vy: 0, onGround: false, facing: 1, ducking: false, invincible: 0 };
  camera = { x: 0 };
  platforms = generatePlatforms();
  pits = generatePits();
  trees = generateTrees();
  enemies = generateEnemies();
  hearts = generateHearts();
  spiders = generateSpiders();
  projectiles = [];
  fireworks = [];
}

function selectCharacter(char) {
  selectedCharacter = char;
  health = 5;
  score = 0;
  initLevel();
  document.getElementById('selectScreen').classList.add('hidden');
  document.getElementById('gameCanvas').classList.remove('hidden');
  document.getElementById('instructions').classList.remove('hidden');
  gameState = 'playing';
  requestAnimationFrame(gameLoop);
}

function restartLevel() {
  health = 5;
  initLevel();
  document.getElementById('gameOverScreen').classList.add('hidden');
  document.getElementById('gameCanvas').classList.remove('hidden');
  document.getElementById('instructions').classList.remove('hidden');
  gameState = 'playing';
  requestAnimationFrame(gameLoop);
}

function backToSelect() {
  document.getElementById('gameOverScreen').classList.add('hidden');
  document.getElementById('victoryScreen').classList.add('hidden');
  document.getElementById('gameCanvas').classList.add('hidden');
  document.getElementById('instructions').classList.add('hidden');
  document.getElementById('selectScreen').classList.remove('hidden');
  score = 0;
  gameState = 'select';
}

// Input handling
document.addEventListener('keydown', (e) => {
  keys[e.code] = true;
  if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) e.preventDefault();
});
document.addEventListener('keyup', (e) => { keys[e.code] = false; });

// Main game loop
function gameLoop() {
  if (gameState !== 'playing' && gameState !== 'victory') return;
  
  update();
  render();
  
  requestAnimationFrame(gameLoop);
}

function update() {
  if (gameState !== 'playing') return;
  
  // Player input
  if (keys['ArrowLeft']) { player.vx = -MOVE_SPEED; player.facing = -1; }
  else if (keys['ArrowRight']) { player.vx = MOVE_SPEED; player.facing = 1; }
  else { player.vx = 0; }
  
  player.ducking = keys['ArrowDown'] && player.onGround;
  const currentHeight = player.ducking ? PLAYER_DUCK_HEIGHT : PLAYER_HEIGHT;
  
  if (keys['ArrowUp'] && player.onGround && !player.ducking) {
    player.vy = JUMP_FORCE;
    player.onGround = false;
  }
  
  // Physics
  player.vy += GRAVITY;
  player.x += player.vx;
  player.y += player.vy;
  
  // Check if over pit
  let overPit = false;
  for (const pit of pits) {
    if (player.x + PLAYER_WIDTH > pit.x && player.x < pit.x + pit.width) {
      overPit = true;
      break;
    }
  }
  
  // Ground collision
  if (!overPit && player.y + currentHeight > GROUND_Y) {
    player.y = GROUND_Y - currentHeight;
    player.vy = 0;
    player.onGround = true;
  }
  
  // Fall into pit
  if (player.y > GAME_HEIGHT + 50) {
    health--;
    if (health <= 0) { endGame(); return; }
    player.y = GROUND_Y - PLAYER_HEIGHT;
    player.x = Math.max(50, player.x - 200);
    player.vy = 0;
    player.invincible = 90;
  }
  
  // Platform collision
  for (const plat of platforms) {
    if (player.x + PLAYER_WIDTH > plat.x && player.x < plat.x + plat.width) {
      if (player.y + currentHeight > plat.y && player.y + currentHeight < plat.y + plat.height + 15 && player.vy > 0) {
        player.y = plat.y - currentHeight;
        player.vy = 0;
        player.onGround = true;
      }
    }
  }
  
  // Boundaries
  player.x = Math.max(0, Math.min(LEVEL_LENGTH - PLAYER_WIDTH, player.x));
  if (player.invincible > 0) player.invincible--;
  
  // Camera
  camera.x = Math.max(0, Math.min(LEVEL_LENGTH - GAME_WIDTH, player.x - GAME_WIDTH / 3));
  
  // Enemy AI
  enemies.forEach(enemy => {
    if (!enemy.alive) return;
    
    enemy.x += enemy.direction * (enemy.type === 'goomba' ? 1.5 : 1);
    if (Math.abs(enemy.x - enemy.startX) > 80) enemy.direction *= -1;
    
    if (enemy.type === 'witch' && enemy.attackCooldown <= 0) {
      const dist = player.x - enemy.x;
      if (Math.abs(dist) < 350 && Math.abs(dist) > 50) {
        projectiles.push({ x: enemy.x + 25, y: enemy.y + 10, vx: dist > 0 ? 4 : -4, vy: -3 });
        enemy.attackCooldown = 150;
      }
    }
    if (enemy.attackCooldown > 0) enemy.attackCooldown--;
    
    // Collision
    const enemyWidth = 50, enemyHeight = 50;
    if (player.x + PLAYER_WIDTH > enemy.x && player.x < enemy.x + enemyWidth) {
      if (player.vy > 0 && player.y + currentHeight > enemy.y && player.y + currentHeight < enemy.y + 25) {
        enemy.alive = false;
        player.vy = JUMP_FORCE * 0.6;
        score += enemy.type === 'witch' ? 200 : 100;
      } else if (player.invincible <= 0 && player.y + currentHeight > enemy.y && player.y < enemy.y + enemyHeight) {
        health--;
        if (health <= 0) { endGame(); return; }
        player.invincible = 90;
        player.vx = player.facing * -8;
      }
    }
  });
  
  // Projectiles
  projectiles = projectiles.filter(proj => {
    proj.x += proj.vx;
    proj.y += proj.vy;
    proj.vy += 0.15;
    
    if (player.invincible <= 0 &&
        player.x + PLAYER_WIDTH > proj.x - 12 && player.x < proj.x + 12 &&
        player.y + currentHeight > proj.y - 12 && player.y < proj.y + 12) {
      health--;
      if (health <= 0) { endGame(); return false; }
      player.invincible = 90;
      return false;
    }
    return proj.y < GAME_HEIGHT && proj.x > camera.x - 50 && proj.x < camera.x + GAME_WIDTH + 50;
  });
  
  // Hearts
  hearts.forEach(heart => {
    if (heart.collected) return;
    if (player.x + PLAYER_WIDTH > heart.x && player.x < heart.x + 30 &&
        player.y + currentHeight > heart.y && player.y < heart.y + 30) {
      heart.collected = true;
      health = Math.min(5, health + 1);
      score += 50;
    }
  });
  
  // Spiders
  spiders.forEach(spider => {
    spider.y += spider.direction * spider.speed;
    if (spider.y < spider.baseY || spider.y > spider.baseY + 200) spider.direction *= -1;
    
    if (player.invincible <= 0 &&
        player.x + PLAYER_WIDTH > spider.x && player.x < spider.x + 80 &&
        player.y + currentHeight > spider.y && player.y < spider.y + 70) {
      health--;
      if (health <= 0) { endGame(); return; }
      player.invincible = 90;
      player.vx = -10;
    }
  });
  
  // Victory
  if (player.x > LEVEL_LENGTH - 100) {
    score += 1000;
    victory();
  }
}

function endGame() {
  gameState = 'gameover';
  document.getElementById('finalScore').textContent = score;
  document.getElementById('gameCanvas').classList.add('hidden');
  document.getElementById('instructions').classList.add('hidden');
  document.getElementById('gameOverScreen').classList.remove('hidden');
}

function victory() {
  gameState = 'victory';
  document.getElementById('victoryScore').textContent = score;
  // Keep canvas visible for fireworks
}

function render() {
  const currentHeight = player.ducking ? PLAYER_DUCK_HEIGHT : PLAYER_HEIGHT;
  
  // Sky gradient
  const skyGradient = ctx.createLinearGradient(0, 0, 0, GAME_HEIGHT);
  skyGradient.addColorStop(0, '#87CEEB');
  skyGradient.addColorStop(0.5, '#B0E0E6');
  skyGradient.addColorStop(1, '#98FB98');
  ctx.fillStyle = skyGradient;
  ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
  
  // Hills
  ctx.fillStyle = '#90EE90';
  for (let i = 0; i < 8; i++) {
    const hillX = (i * 250 - camera.x * 0.2) % (GAME_WIDTH + 400) - 200;
    ctx.beginPath();
    ctx.arc(hillX, GROUND_Y + 50, 120 + (i % 3) * 30, Math.PI, 0);
    ctx.fill();
  }
  
  // Background trees
  trees.forEach(tree => {
    if (tree.layer !== 'back') return;
    const screenX = tree.x - camera.x * 0.5;
    if (screenX > -100 && screenX < GAME_WIDTH + 100) {
      ctx.fillStyle = '#654321';
      ctx.fillRect(screenX, GROUND_Y - tree.height, tree.trunkWidth, tree.height);
      ctx.fillStyle = '#228B22';
      ctx.beginPath();
      ctx.arc(screenX + tree.trunkWidth / 2, GROUND_Y - tree.height - tree.canopySize / 2, tree.canopySize, 0, Math.PI * 2);
      ctx.fill();
    }
  });
  
  // Ground
  const groundGradient = ctx.createLinearGradient(0, GROUND_Y, 0, GAME_HEIGHT);
  groundGradient.addColorStop(0, '#228B22');
  groundGradient.addColorStop(0.1, '#32CD32');
  groundGradient.addColorStop(0.3, '#8B4513');
  groundGradient.addColorStop(1, '#654321');
  ctx.fillStyle = groundGradient;
  
  let lastX = 0;
  const sortedPits = [...pits].sort((a, b) => a.x - b.x);
  sortedPits.forEach(pit => {
    const startScreen = lastX - camera.x;
    const pitStartScreen = pit.x - camera.x;
    if (pitStartScreen > -200 && startScreen < GAME_WIDTH + 200) {
      ctx.fillRect(Math.max(0, startScreen), GROUND_Y, pit.x - lastX, GAME_HEIGHT - GROUND_Y);
    }
    lastX = pit.x + pit.width;
  });
  ctx.fillRect(Math.max(0, lastX - camera.x), GROUND_Y, GAME_WIDTH, GAME_HEIGHT - GROUND_Y);
  
  // Pits
  pits.forEach(pit => {
    const screenX = pit.x - camera.x;
    if (screenX > -pit.width && screenX < GAME_WIDTH) {
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(screenX, GROUND_Y, pit.width, GAME_HEIGHT - GROUND_Y);
      ctx.fillStyle = '#808080';
      for (let s = 0; s < pit.width; s += 15) {
        ctx.beginPath();
        ctx.moveTo(screenX + s, GAME_HEIGHT);
        ctx.lineTo(screenX + s + 7, GAME_HEIGHT - 20);
        ctx.lineTo(screenX + s + 14, GAME_HEIGHT);
        ctx.fill();
      }
    }
  });
  
  // Platforms
  platforms.forEach(plat => {
    const screenX = plat.x - camera.x;
    if (screenX > -plat.width && screenX < GAME_WIDTH) {
      ctx.fillStyle = '#8B4513';
      ctx.fillRect(screenX, plat.y, plat.width, plat.height);
      ctx.fillStyle = '#32CD32';
      ctx.fillRect(screenX, plat.y - 5, plat.width, 8);
    }
  });
  
  // Hearts
  hearts.forEach(heart => {
    if (heart.collected) return;
    const screenX = heart.x - camera.x;
    if (screenX > -30 && screenX < GAME_WIDTH) {
      ctx.fillStyle = '#FF0000';
      ctx.beginPath();
      ctx.moveTo(screenX + 15, heart.y + 5);
      ctx.bezierCurveTo(screenX + 15, heart.y, screenX, heart.y, screenX, heart.y + 10);
      ctx.bezierCurveTo(screenX, heart.y + 20, screenX + 15, heart.y + 25, screenX + 15, heart.y + 30);
      ctx.bezierCurveTo(screenX + 15, heart.y + 25, screenX + 30, heart.y + 20, screenX + 30, heart.y + 10);
      ctx.bezierCurveTo(screenX + 30, heart.y, screenX + 15, heart.y, screenX + 15, heart.y + 5);
      ctx.fill();
    }
  });
  
  // Enemies
  enemies.forEach(enemy => {
    if (!enemy.alive) return;
    const screenX = enemy.x - camera.x;
    if (screenX > -60 && screenX < GAME_WIDTH + 60) {
      const img = enemy.type === 'goomba' ? images.goomba : images.witch;
      if (img) {
        ctx.save();
        if (enemy.direction < 0) {
          ctx.translate(screenX + 50, 0);
          ctx.scale(-1, 1);
          ctx.drawImage(img, 0, enemy.y - 10, 50, 60);
        } else {
          ctx.drawImage(img, screenX, enemy.y - 10, 50, 60);
        }
        ctx.restore();
      }
    }
  });
  
  // Projectiles
  projectiles.forEach(proj => {
    const screenX = proj.x - camera.x;
    ctx.fillStyle = '#800080';
    ctx.beginPath();
    ctx.arc(screenX, proj.y, 10, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#DDA0DD';
    ctx.beginPath();
    ctx.arc(screenX - proj.vx * 2, proj.y + 5, 3, 0, Math.PI * 2);
    ctx.fill();
  });
  
  // Spiders
  spiders.forEach(spider => {
    const screenX = spider.x - camera.x;
    if (screenX > -100 && screenX < GAME_WIDTH + 100) {
      ctx.strokeStyle = '#AAA';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(screenX + 40, 0);
      ctx.lineTo(screenX + 40, spider.y);
      ctx.stroke();
      
      if (images.boss) {
        ctx.drawImage(images.boss, screenX, spider.y, 80, 70);
      }
    }
  });
  
  // Foreground trees
  trees.forEach(tree => {
    if (tree.layer !== 'front') return;
    const screenX = tree.x - camera.x;
    if (screenX > -100 && screenX < GAME_WIDTH + 100) {
      ctx.fillStyle = '#5D4037';
      ctx.fillRect(screenX, GROUND_Y - tree.height, tree.trunkWidth, tree.height);
      ctx.fillStyle = '#2E7D32';
      ctx.beginPath();
      ctx.arc(screenX + tree.trunkWidth / 2, GROUND_Y - tree.height - tree.canopySize / 2, tree.canopySize, 0, Math.PI * 2);
      ctx.fill();
    }
  });
  
  // Player
  const playerScreenX = player.x - camera.x;
  if (!(player.invincible > 0 && Math.floor(player.invincible / 4) % 2 === 0)) {
    const playerImg = selectedCharacter === 'boy' ? images.boy : images.girl;
    if (playerImg) {
      ctx.save();
      const drawHeight = player.ducking ? PLAYER_DUCK_HEIGHT : PLAYER_HEIGHT;
      const drawY = player.ducking ? player.y + 20 : player.y;
      if (player.facing < 0) {
        ctx.translate(playerScreenX + PLAYER_WIDTH, 0);
        ctx.scale(-1, 1);
        ctx.drawImage(playerImg, 0, drawY, PLAYER_WIDTH, drawHeight);
      } else {
        ctx.drawImage(playerImg, playerScreenX, drawY, PLAYER_WIDTH, drawHeight);
      }
      ctx.restore();
    }
  }
  
  // HUD - Health
  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  ctx.fillRect(10, 10, 180, 50);
  ctx.strokeStyle = '#FFD700';
  ctx.lineWidth = 2;
  ctx.strokeRect(10, 10, 180, 50);
  
  for (let i = 0; i < 5; i++) {
    ctx.fillStyle = i < health ? '#FF0000' : '#333';
    ctx.beginPath();
    const hx = 20 + i * 32;
    ctx.moveTo(hx + 12, 28);
    ctx.bezierCurveTo(hx + 12, 24, hx + 4, 22, hx + 4, 28);
    ctx.bezierCurveTo(hx + 4, 36, hx + 12, 40, hx + 12, 46);
    ctx.bezierCurveTo(hx + 12, 40, hx + 20, 36, hx + 20, 28);
    ctx.bezierCurveTo(hx + 20, 22, hx + 12, 24, hx + 12, 28);
    ctx.fill();
  }
  
  // HUD - Score & Progress
  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  ctx.fillRect(GAME_WIDTH - 160, 10, 150, 50);
  ctx.strokeStyle = '#FFD700';
  ctx.strokeRect(GAME_WIDTH - 160, 10, 150, 50);
  
  ctx.fillStyle = '#FFF';
  ctx.font = 'bold 14px Arial';
  ctx.fillText('Score: ' + score, GAME_WIDTH - 150, 30);
  
  const progress = Math.min(1, player.x / LEVEL_LENGTH);
  ctx.fillStyle = '#333';
  ctx.fillRect(GAME_WIDTH - 150, 40, 130, 12);
  ctx.fillStyle = '#32CD32';
  ctx.fillRect(GAME_WIDTH - 150, 40, 130 * progress, 12);
  
  // Victory fireworks
  if (gameState === 'victory') {
    if (Math.random() < 0.15) {
      fireworks.push({
        x: Math.random() * GAME_WIDTH, y: GAME_HEIGHT,
        vy: -8 - Math.random() * 5,
        color: ['#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF'][Math.floor(Math.random() * 6)],
        exploded: false, particles: []
      });
    }
    
    fireworks = fireworks.filter(fw => {
      if (!fw.exploded) {
        fw.y += fw.vy;
        ctx.fillStyle = fw.color;
        ctx.beginPath();
        ctx.arc(fw.x, fw.y, 6, 0, Math.PI * 2);
        ctx.fill();
        if (fw.vy > -2) {
          fw.exploded = true;
          for (let i = 0; i < 30; i++) {
            fw.particles.push({ x: fw.x, y: fw.y, vx: (Math.random() - 0.5) * 12, vy: (Math.random() - 0.5) * 12, life: 60 });
          }
        }
      } else {
        fw.particles = fw.particles.filter(p => {
          p.x += p.vx; p.y += p.vy; p.vy += 0.15; p.life--;
          ctx.fillStyle = fw.color;
          ctx.globalAlpha = p.life / 60;
          ctx.beginPath();
          ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 1;
          return p.life > 0;
        });
        return fw.particles.length > 0;
      }
      return true;
    });
    
    // Victory text
    ctx.fillStyle = '#FFD700';
    ctx.font = 'bold 48px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('YOU WIN!', GAME_WIDTH / 2, GAME_HEIGHT / 2);
    ctx.font = 'bold 24px Arial';
    ctx.fillText('Score: ' + score, GAME_WIDTH / 2, GAME_HEIGHT / 2 + 40);
    ctx.textAlign = 'left';
  }
}

// Start loading
loadImages();
</script>
</body>
</html>
