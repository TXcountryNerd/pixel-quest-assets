<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Forest Run Adventure</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      background: linear-gradient(to bottom, #1a472a, #2d5a3f);
      font-family: Arial, sans-serif;
      padding: 20px;
    }
    h1 {
      font-size: 2.5rem;
      background: linear-gradient(to right, #ffd700, #32cd32);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 20px;
    }
    #gameCanvas {
      border: 4px solid #daa520;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(50, 205, 50, 0.3);
    }
    .menu, .overlay {
      background: rgba(26, 71, 42, 0.95);
      padding: 30px;
      border-radius: 10px;
      border: 2px solid #ffd700;
      text-align: center;
      color: white;
    }
    .char-select { display: flex; gap: 30px; margin: 20px 0; }
    .char-btn {
      background: #2563eb;
      border: 2px solid #60a5fa;
      padding: 20px 30px;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.2s;
      color: white;
      font-weight: bold;
    }
    .char-btn:hover { transform: scale(1.05); background: #3b82f6; }
    .char-btn.girl { background: #7c3aed; border-color: #a78bfa; }
    .char-btn.girl:hover { background: #8b5cf6; }
    .char-btn img { width: 80px; height: 100px; object-fit: contain; display: block; margin: 0 auto 10px; }
    .controls { margin-top: 15px; padding-top: 15px; border-top: 1px solid #4a7c59; color: #9ca3af; font-size: 14px; }
    .controls span { color: #ffd700; }
    .tip { color: #4ade80; margin-top: 5px; }
    .warning { color: #f87171; }
    button {
      background: #16a34a;
      color: white;
      border: none;
      padding: 12px 30px;
      border-radius: 8px;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      margin: 5px;
      transition: all 0.2s;
    }
    button:hover { background: #22c55e; transform: scale(1.05); }
    button.secondary { background: #4b5563; }
    button.secondary:hover { background: #6b7280; }
    .hidden { display: none; }
    #instructions {
      margin-top: 15px;
      color: #d1d5db;
      font-size: 14px;
      background: rgba(0,0,0,0.3);
      padding: 10px 20px;
      border-radius: 8px;
    }
    .score-display {
      font-size: 1.5rem;
      color: #ffd700;
      margin: 10px 0;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    }
    .high-scores {
      background: rgba(0,0,0,0.4);
      padding: 15px;
      border-radius: 8px;
      margin-top: 15px;
    }
    .high-scores h3 { color: #ffd700; margin-bottom: 10px; }
    .high-scores p { color: #9ca3af; font-size: 14px; }
  </style>
</head>
<body>
  <h1>üå≤ Forest Run Adventure üå≤</h1>
  
  <div id="loadingScreen" class="menu">
    <h2>Loading...</h2>
    <div style="width: 250px; height: 20px; background: #374151; border-radius: 10px; overflow: hidden; margin: 20px auto;">
      <div id="loadingBar" style="width: 0%; height: 100%; background: linear-gradient(to right, #4ade80, #ffd700); transition: width 0.3s;"></div>
    </div>
    <p id="loadingText">0%</p>
  </div>
  
  <div id="selectScreen" class="menu hidden">
    <h2>Choose Your Hero!</h2>
    <div class="char-select">
      <button class="char-btn" onclick="selectCharacter('boy')">
        <img src="https://txcountrynerd.github.io/pixel-quest-assets/boy-transparent-2.png" alt="Boy">
        Boy Hero
      </button>
      <button class="char-btn girl" onclick="selectCharacter('girl')">
        <img src="https://txcountrynerd.github.io/pixel-quest-assets/girl-transparent-2.png" alt="Girl">
        Girl Hero
      </button>
    </div>
    <div class="high-scores">
      <h3>üèÜ Best Scores</h3>
      <div id="bestScores"><p>No scores yet - be the first!</p></div>
    </div>
    <div class="controls">
      <p><span>‚Üê ‚Üí</span> Move | <span>‚Üë</span> Jump | <span>‚Üì</span> Duck</p>
      <p class="tip">Jump on enemies to defeat them!</p>
      <p class="warning">‚è±Ô∏è Complete in 3 minutes or lose!</p>
    </div>
  </div>
  
  <canvas id="gameCanvas" class="hidden" width="800" height="500"></canvas>
  
  <div id="gameOverScreen" class="overlay hidden">
    <h2 style="color: #ef4444; font-size: 2.5rem; margin-bottom: 15px;">GAME OVER</h2>
    <p id="gameOverReason" style="color: #fca5a5; margin-bottom: 10px;"></p>
    <p class="score-display">Score: <span id="finalScore">0</span></p>
    <button onclick="restartLevel()">Try Again</button>
    <button class="secondary" onclick="backToSelect()">New Game</button>
  </div>
  
  <div id="victoryScreen" class="overlay hidden">
    <h2 style="color: #ffd700; font-size: 2.5rem; margin-bottom: 15px;">üéâ YOU WIN! üéâ</h2>
    <p style="margin-bottom: 10px;">You escaped the forest!</p>
    <p class="score-display">Final Score: <span id="victoryScore">0</span></p>
    <p style="margin-bottom: 5px;">Time Bonus: <span id="timeBonus" style="color: #4ade80;">+0</span></p>
    <p style="margin-bottom: 20px; font-size: 1.2rem;">Total: <span id="totalScore" style="color: #ffd700; font-weight: bold;">0</span></p>
    <button onclick="backToSelect()">Play Again</button>
  </div>
  
  <div id="instructions" class="hidden">
    <span style="color: #ffd700;">‚Üê ‚Üí</span> Move | 
    <span style="color: #ffd700;">‚Üë</span> Jump | 
    <span style="color: #ffd700;">‚Üì</span> Duck | 
    <span style="color: #4ade80;">Stomp enemies!</span> |
    <span style="color: #f87171;">‚è±Ô∏è Beat the clock!</span>
  </div>

<script>
// Game constants
const GAME_WIDTH = 800;
const GAME_HEIGHT = 500;
const GRAVITY = 0.6;
const JUMP_FORCE = -14;
const MOVE_SPEED = 5;
const PLAYER_WIDTH = 40;
const PLAYER_HEIGHT = 60;
const PLAYER_DUCK_HEIGHT = 35;
const GROUND_Y = 420;
const LEVEL_LENGTH = 8000; // Longer level (~30 sec more)
const TIME_LIMIT = 180; // 3 minutes in seconds

// Updated sprite URLs
const SPRITE_URLS = {
  boy: 'https://txcountrynerd.github.io/pixel-quest-assets/boy-transparent-2.png',
  girl: 'https://txcountrynerd.github.io/pixel-quest-assets/girl-transparent-2.png',
  goomba: 'https://txcountrynerd.github.io/pixel-quest-assets/goomba-transparent-2.png',
  witch: 'https://txcountrynerd.github.io/pixel-quest-assets/witch-transparent-2.png',
  boss: 'https://txcountrynerd.github.io/pixel-quest-assets/boss-transparent-2.png'
};

// Game state
let gameState = 'loading';
let selectedCharacter = null;
let health = 5;
let score = 0;
let timeRemaining = TIME_LIMIT;
let timerInterval = null;
let images = {};
let bestScores = JSON.parse(localStorage.getItem('forestRunScores') || '[]');

let player = { x: 50, y: GROUND_Y - PLAYER_HEIGHT, vx: 0, vy: 0, onGround: false, facing: 1, ducking: false, invincible: 0 };
let platforms = [];
let pits = [];
let trees = [];
let enemies = [];
let hearts = [];
let spiders = [];
let projectiles = [];
let clouds = []; // For witches on clouds
let camera = { x: 0 };
let keys = {};
let fireworks = [];

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Load images
function loadImages() {
  const spriteKeys = Object.keys(SPRITE_URLS);
  let loaded = 0;
  
  spriteKeys.forEach(key => {
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.onload = () => {
      images[key] = img;
      loaded++;
      updateLoading(loaded, spriteKeys.length);
    };
    img.onerror = () => {
      console.error('Failed to load:', key);
      loaded++;
      updateLoading(loaded, spriteKeys.length);
    };
    img.src = SPRITE_URLS[key];
  });
}

function updateLoading(loaded, total) {
  const pct = Math.floor((loaded / total) * 100);
  document.getElementById('loadingBar').style.width = pct + '%';
  document.getElementById('loadingText').textContent = pct + '%';
  if (loaded === total) {
    setTimeout(() => {
      document.getElementById('loadingScreen').classList.add('hidden');
      document.getElementById('selectScreen').classList.remove('hidden');
      displayBestScores();
      gameState = 'select';
    }, 300);
  }
}

function displayBestScores() {
  const container = document.getElementById('bestScores');
  if (bestScores.length === 0) {
    container.innerHTML = '<p>No scores yet - be the first!</p>';
  } else {
    const top5 = bestScores.slice(0, 5);
    container.innerHTML = top5.map((s, i) => 
      `<p style="color: ${i === 0 ? '#ffd700' : '#fff'};">${i + 1}. ${s.score} pts - ${s.character} (${formatTime(s.time)})</p>`
    ).join('');
  }
}

function formatTime(seconds) {
  const m = Math.floor(seconds / 60);
  const s = seconds % 60;
  return `${m}:${s.toString().padStart(2, '0')}`;
}

function saveScore(finalScore, timeUsed) {
  bestScores.push({ score: finalScore, character: selectedCharacter, time: timeUsed });
  bestScores.sort((a, b) => b.score - a.score);
  bestScores = bestScores.slice(0, 10);
  localStorage.setItem('forestRunScores', JSON.stringify(bestScores));
}

// Level generation
function generatePlatforms() {
  const p = [];
  let x = 200;
  while (x < LEVEL_LENGTH - 1000) {
    const y = 280 + Math.random() * 100;
    const width = 60 + Math.random() * 80;
    // Mark some platforms to have goombas
    const hasGoomba = Math.random() > 0.7 && x > 500 && x < LEVEL_LENGTH - 1500;
    p.push({ x, y, width, height: 20, hasGoomba });
    x += 150 + Math.random() * 200;
  }
  return p;
}

function generatePits() {
  const p = [];
  let x = 400;
  while (x < LEVEL_LENGTH - 1500) {
    const width = 80 + Math.random() * 60;
    p.push({ x, width });
    x += 400 + Math.random() * 300;
  }
  return p;
}

// Skill jump sections - 3 sequential pits with small landings
function generateSkillSections() {
  const sections = [];
  // First skill section around 1/3 of level
  sections.push({ startX: 2500, pits: [
    { x: 2500, width: 100 },
    { x: 2650, width: 100 },
    { x: 2800, width: 100 }
  ], platforms: [
    { x: 2600, y: 380, width: 50, height: 20 },
    { x: 2750, y: 360, width: 50, height: 20 }
  ]});
  
  // Second skill section around 2/3 of level
  sections.push({ startX: 5000, pits: [
    { x: 5000, width: 120 },
    { x: 5180, width: 120 },
    { x: 5360, width: 120 }
  ], platforms: [
    { x: 5120, y: 370, width: 60, height: 20 },
    { x: 5300, y: 350, width: 60, height: 20 }
  ]});
  
  return sections;
}

function generateTrees() {
  const t = [];
  let x = 100;
  while (x < LEVEL_LENGTH - 200) {
    t.push({
      x, height: 150 + Math.random() * 100,
      trunkWidth: 20 + Math.random() * 15,
      canopySize: 40 + Math.random() * 30,
      layer: Math.random() > 0.5 ? 'back' : 'front'
    });
    x += 80 + Math.random() * 120;
  }
  return t;
}

function generateEnemies() {
  const e = [];
  let x = 300;
  let id = 0;
  while (x < LEVEL_LENGTH - 1500) {
    // Ground enemies only (not on skill sections)
    const inSkillSection = (x > 2400 && x < 3000) || (x > 4900 && x < 5600);
    if (!inSkillSection) {
      const type = Math.random() > 0.75 ? 'witch' : 'goomba';
      if (type === 'goomba') {
        e.push({
          id: id++, x, y: GROUND_Y - 50, startX: x,
          type: 'goomba', direction: 1, alive: true, attackCooldown: 0, onPlatform: false
        });
      }
      // Witches now go on clouds instead
    }
    const spacing = x < 2000 ? 350 : x < 5000 ? 280 : 220;
    x += spacing + Math.random() * 150;
  }
  return e;
}

// Platform goombas
function generatePlatformEnemies(platforms) {
  const e = [];
  let id = 1000;
  platforms.forEach(plat => {
    if (plat.hasGoomba) {
      e.push({
        id: id++, x: plat.x + 10, y: plat.y - 50, startX: plat.x + 10,
        type: 'goomba', direction: 1, alive: true, attackCooldown: 0,
        onPlatform: true, platformX: plat.x, platformWidth: plat.width
      });
    }
  });
  return e;
}

// Witches on floating clouds
function generateCloudsWithWitches() {
  const c = [];
  let x = 600;
  let id = 2000;
  while (x < LEVEL_LENGTH - 1500) {
    if (Math.random() > 0.5) {
      c.push({
        x, y: 150 + Math.random() * 100,
        width: 80, height: 30,
        witch: {
          id: id++, alive: true, attackCooldown: 0, direction: 1
        }
      });
    }
    x += 500 + Math.random() * 400;
  }
  return c;
}

function generateHearts() {
  const h = [];
  let x = 600;
  while (x < LEVEL_LENGTH - 1000) {
    h.push({ x, y: 250 + Math.random() * 100, collected: false });
    x += 700 + Math.random() * 400;
  }
  return h;
}

// Spiders that reach the ground!
function generateSpiders() {
  const s = [];
  const startX = LEVEL_LENGTH - 700;
  for (let i = 0; i < 5; i++) {
    const baseY = 50 + (i % 2) * 30; // Stagger starting heights
    s.push({
      x: startX + i * 120,
      y: baseY,
      baseY: baseY,
      maxY: GROUND_Y - 70, // Spiders now reach near ground level!
      direction: 1,
      speed: 2 + Math.random() * 1.5,
      phase: i * 0.5 // Offset timing so they're not synchronized
    });
  }
  return s;
}

let skillSections = [];

function initLevel() {
  player = { x: 50, y: GROUND_Y - PLAYER_HEIGHT, vx: 0, vy: 0, onGround: false, facing: 1, ducking: false, invincible: 0 };
  camera = { x: 0 };
  
  // Generate skill sections first (so we can exclude them from regular pits)
  skillSections = generateSkillSections();
  
  platforms = generatePlatforms();
  
  // Add skill section platforms
  skillSections.forEach(section => {
    section.platforms.forEach(p => platforms.push(p));
  });
  
  pits = generatePits();
  
  // Remove regular pits that overlap with skill sections
  pits = pits.filter(pit => {
    for (const section of skillSections) {
      if (pit.x > section.startX - 200 && pit.x < section.startX + 600) return false;
    }
    return true;
  });
  
  // Add skill section pits
  skillSections.forEach(section => {
    section.pits.forEach(p => pits.push(p));
  });
  
  trees = generateTrees();
  enemies = generateEnemies();
  
  // Add platform goombas
  const platEnemies = generatePlatformEnemies(platforms);
  enemies = enemies.concat(platEnemies);
  
  clouds = generateCloudsWithWitches();
  hearts = generateHearts();
  spiders = generateSpiders();
  projectiles = [];
  fireworks = [];
  
  // Reset timer
  timeRemaining = TIME_LIMIT;
  if (timerInterval) clearInterval(timerInterval);
  timerInterval = setInterval(() => {
    if (gameState === 'playing') {
      timeRemaining--;
      if (timeRemaining <= 0) {
        timeOut();
      }
    }
  }, 1000);
}

function selectCharacter(char) {
  selectedCharacter = char;
  health = 5;
  score = 0;
  initLevel();
  document.getElementById('selectScreen').classList.add('hidden');
  document.getElementById('gameCanvas').classList.remove('hidden');
  document.getElementById('instructions').classList.remove('hidden');
  gameState = 'playing';
  requestAnimationFrame(gameLoop);
}

function restartLevel() {
  health = 5;
  score = 0;
  initLevel();
  document.getElementById('gameOverScreen').classList.add('hidden');
  document.getElementById('gameCanvas').classList.remove('hidden');
  document.getElementById('instructions').classList.remove('hidden');
  gameState = 'playing';
  requestAnimationFrame(gameLoop);
}

function backToSelect() {
  if (timerInterval) clearInterval(timerInterval);
  document.getElementById('gameOverScreen').classList.add('hidden');
  document.getElementById('victoryScreen').classList.add('hidden');
  document.getElementById('gameCanvas').classList.add('hidden');
  document.getElementById('instructions').classList.add('hidden');
  document.getElementById('selectScreen').classList.remove('hidden');
  displayBestScores();
  score = 0;
  gameState = 'select';
}

function timeOut() {
  if (timerInterval) clearInterval(timerInterval);
  gameState = 'gameover';
  document.getElementById('gameOverReason').textContent = "‚è±Ô∏è Time's up!";
  document.getElementById('finalScore').textContent = score;
  document.getElementById('gameCanvas').classList.add('hidden');
  document.getElementById('instructions').classList.add('hidden');
  document.getElementById('gameOverScreen').classList.remove('hidden');
}

// Input handling
document.addEventListener('keydown', (e) => {
  keys[e.code] = true;
  if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) e.preventDefault();
});
document.addEventListener('keyup', (e) => { keys[e.code] = false; });

// Main game loop
function gameLoop() {
  if (gameState !== 'playing' && gameState !== 'victory') return;
  
  update();
  render();
  
  requestAnimationFrame(gameLoop);
}

function update() {
  if (gameState !== 'playing') return;
  
  const currentHeight = player.ducking ? PLAYER_DUCK_HEIGHT : PLAYER_HEIGHT;
  
  // Player input
  if (keys['ArrowLeft']) { player.vx = -MOVE_SPEED; player.facing = -1; }
  else if (keys['ArrowRight']) { player.vx = MOVE_SPEED; player.facing = 1; }
  else { player.vx = 0; }
  
  player.ducking = keys['ArrowDown'] && player.onGround;
  
  if (keys['ArrowUp'] && player.onGround && !player.ducking) {
    player.vy = JUMP_FORCE;
    player.onGround = false;
  }
  
  // Physics
  player.vy += GRAVITY;
  player.x += player.vx;
  player.y += player.vy;
  
  // Check if over pit
  let overPit = false;
  for (const pit of pits) {
    if (player.x + PLAYER_WIDTH > pit.x && player.x < pit.x + pit.width) {
      overPit = true;
      break;
    }
  }
  
  // Ground collision
  if (!overPit && player.y + currentHeight > GROUND_Y) {
    player.y = GROUND_Y - currentHeight;
    player.vy = 0;
    player.onGround = true;
  }
  
  // Fall into pit
  if (player.y > GAME_HEIGHT + 50) {
    health--;
    if (health <= 0) { endGame('Fell into a pit!'); return; }
    player.y = GROUND_Y - PLAYER_HEIGHT;
    player.x = Math.max(50, player.x - 200);
    player.vy = 0;
    player.invincible = 90;
  }
  
  // Platform collision
  for (const plat of platforms) {
    if (player.x + PLAYER_WIDTH > plat.x && player.x < plat.x + plat.width) {
      if (player.y + currentHeight > plat.y && player.y + currentHeight < plat.y + plat.height + 15 && player.vy > 0) {
        player.y = plat.y - currentHeight;
        player.vy = 0;
        player.onGround = true;
      }
    }
  }
  
  // Boundaries
  player.x = Math.max(0, Math.min(LEVEL_LENGTH - PLAYER_WIDTH, player.x));
  if (player.invincible > 0) player.invincible--;
  
  // Camera
  camera.x = Math.max(0, Math.min(LEVEL_LENGTH - GAME_WIDTH, player.x - GAME_WIDTH / 3));
  
  // Enemy AI (ground and platform goombas)
  enemies.forEach(enemy => {
    if (!enemy.alive) return;
    
    if (enemy.onPlatform) {
      // Platform goomba - patrol on platform only
      enemy.x += enemy.direction * 1.2;
      if (enemy.x < enemy.platformX || enemy.x > enemy.platformX + enemy.platformWidth - 40) {
        enemy.direction *= -1;
      }
    } else {
      // Ground enemy
      enemy.x += enemy.direction * 1.5;
      if (Math.abs(enemy.x - enemy.startX) > 80) enemy.direction *= -1;
    }
    
    // Collision with player
    const enemyWidth = 50, enemyHeight = 50;
    const enemyY = enemy.onPlatform ? enemy.y : enemy.y;
    
    if (player.x + PLAYER_WIDTH > enemy.x && player.x < enemy.x + enemyWidth) {
      if (player.vy > 0 && player.y + currentHeight > enemyY && player.y + currentHeight < enemyY + 25) {
        enemy.alive = false;
        player.vy = JUMP_FORCE * 0.6;
        score += 100;
      } else if (player.invincible <= 0 && player.y + currentHeight > enemyY && player.y < enemyY + enemyHeight) {
        health--;
        if (health <= 0) { endGame('Hit by a Goomba!'); return; }
        player.invincible = 90;
        player.vx = player.facing * -8;
      }
    }
  });
  
  // Cloud witches
  clouds.forEach(cloud => {
    if (!cloud.witch.alive) return;
    
    // Witch throws potions
    if (cloud.witch.attackCooldown <= 0) {
      const dist = player.x - cloud.x;
      if (Math.abs(dist) < 400 && Math.abs(dist) > 50) {
        projectiles.push({
          x: cloud.x + 40,
          y: cloud.y + 50,
          vx: dist > 0 ? 3.5 : -3.5,
          vy: 1
        });
        cloud.witch.attackCooldown = 120;
      }
    }
    if (cloud.witch.attackCooldown > 0) cloud.witch.attackCooldown--;
  });
  
  // Projectiles
  projectiles = projectiles.filter(proj => {
    proj.x += proj.vx;
    proj.y += proj.vy;
    proj.vy += 0.12;
    
    if (player.invincible <= 0 &&
        player.x + PLAYER_WIDTH > proj.x - 12 && player.x < proj.x + 12 &&
        player.y + currentHeight > proj.y - 12 && player.y < proj.y + 12) {
      health--;
      if (health <= 0) { endGame('Hit by a potion!'); return false; }
      player.invincible = 90;
      return false;
    }
    return proj.y < GAME_HEIGHT + 20 && proj.x > camera.x - 50 && proj.x < camera.x + GAME_WIDTH + 50;
  });
  
  // Hearts
  hearts.forEach(heart => {
    if (heart.collected) return;
    if (player.x + PLAYER_WIDTH > heart.x && player.x < heart.x + 30 &&
        player.y + currentHeight > heart.y && player.y < heart.y + 30) {
      heart.collected = true;
      health = Math.min(5, health + 1);
      score += 50;
    }
  });
  
  // Spiders - now reach the ground!
  spiders.forEach(spider => {
    spider.y += spider.direction * spider.speed;
    
    // Bounce between top and near-ground
    if (spider.y >= spider.maxY) {
      spider.direction = -1;
    } else if (spider.y <= spider.baseY) {
      spider.direction = 1;
    }
    
    const spiderWidth = 80, spiderHeight = 70;
    
    if (player.invincible <= 0 &&
        player.x + PLAYER_WIDTH > spider.x && player.x < spider.x + spiderWidth &&
        player.y + currentHeight > spider.y && player.y < spider.y + spiderHeight) {
      health--;
      if (health <= 0) { endGame('Caught by a spider!'); return; }
      player.invincible = 90;
      player.vx = -10;
    }
  });
  
  // Victory
  if (player.x > LEVEL_LENGTH - 100) {
    victory();
  }
}

function endGame(reason) {
  if (timerInterval) clearInterval(timerInterval);
  gameState = 'gameover';
  document.getElementById('gameOverReason').textContent = reason || '';
  document.getElementById('finalScore').textContent = score;
  document.getElementById('gameCanvas').classList.add('hidden');
  document.getElementById('instructions').classList.add('hidden');
  document.getElementById('gameOverScreen').classList.remove('hidden');
}

function victory() {
  if (timerInterval) clearInterval(timerInterval);
  gameState = 'victory';
  
  // Calculate time bonus (more time left = more points)
  const timeUsed = TIME_LIMIT - timeRemaining;
  const timeBonus = timeRemaining * 10; // 10 points per second remaining
  const totalScore = score + timeBonus + 1000; // +1000 for completing
  
  document.getElementById('victoryScore').textContent = score;
  document.getElementById('timeBonus').textContent = '+' + timeBonus;
  document.getElementById('totalScore').textContent = totalScore;
  
  saveScore(totalScore, timeUsed);
}

function render() {
  const currentHeight = player.ducking ? PLAYER_DUCK_HEIGHT : PLAYER_HEIGHT;
  
  // Sky gradient
  const skyGradient = ctx.createLinearGradient(0, 0, 0, GAME_HEIGHT);
  skyGradient.addColorStop(0, '#87CEEB');
  skyGradient.addColorStop(0.5, '#B0E0E6');
  skyGradient.addColorStop(1, '#98FB98');
  ctx.fillStyle = skyGradient;
  ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
  
  // Easter egg - "made by Sarah with AI" in the sky (appears in middle of level)
  const easterEggX = 4000; // Middle-ish of the level
  const eggScreenX = easterEggX - camera.x;
  if (eggScreenX > -300 && eggScreenX < GAME_WIDTH + 100) {
    ctx.save();
    ctx.font = 'italic 16px Georgia';
    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
    ctx.fillText('‚ú® made by Sarah with AI ‚ú®', eggScreenX, 60);
    ctx.restore();
  }
  
  // Hills
  ctx.fillStyle = '#90EE90';
  for (let i = 0; i < 8; i++) {
    const hillX = (i * 250 - camera.x * 0.2) % (GAME_WIDTH + 400) - 200;
    ctx.beginPath();
    ctx.arc(hillX, GROUND_Y + 50, 120 + (i % 3) * 30, Math.PI, 0);
    ctx.fill();
  }
  
  // Background trees
  trees.forEach(tree => {
    if (tree.layer !== 'back') return;
    const screenX = tree.x - camera.x * 0.5;
    if (screenX > -100 && screenX < GAME_WIDTH + 100) {
      ctx.fillStyle = '#654321';
      ctx.fillRect(screenX, GROUND_Y - tree.height, tree.trunkWidth, tree.height);
      ctx.fillStyle = '#228B22';
      ctx.beginPath();
      ctx.arc(screenX + tree.trunkWidth / 2, GROUND_Y - tree.height - tree.canopySize / 2, tree.canopySize, 0, Math.PI * 2);
      ctx.fill();
    }
  });
  
  // Clouds with witches
  clouds.forEach(cloud => {
    const screenX = cloud.x - camera.x;
    if (screenX > -100 && screenX < GAME_WIDTH + 100) {
      // Draw cloud
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(screenX + 20, cloud.y + 15, 25, 0, Math.PI * 2);
      ctx.arc(screenX + 50, cloud.y + 10, 30, 0, Math.PI * 2);
      ctx.arc(screenX + 80, cloud.y + 15, 25, 0, Math.PI * 2);
      ctx.fill();
      
      // Draw witch on cloud
      if (cloud.witch.alive && images.witch) {
        ctx.drawImage(images.witch, screenX + 25, cloud.y - 50, 45, 55);
      }
    }
  });
  
  // Ground
  const groundGradient = ctx.createLinearGradient(0, GROUND_Y, 0, GAME_HEIGHT);
  groundGradient.addColorStop(0, '#228B22');
  groundGradient.addColorStop(0.1, '#32CD32');
  groundGradient.addColorStop(0.3, '#8B4513');
  groundGradient.addColorStop(1, '#654321');
  ctx.fillStyle = groundGradient;
  
  let lastX = 0;
  const sortedPits = [...pits].sort((a, b) => a.x - b.x);
  sortedPits.forEach(pit => {
    const startScreen = lastX - camera.x;
    ctx.fillRect(Math.max(0, startScreen), GROUND_Y, pit.x - lastX, GAME_HEIGHT - GROUND_Y);
    lastX = pit.x + pit.width;
  });
  ctx.fillRect(Math.max(0, lastX - camera.x), GROUND_Y, GAME_WIDTH, GAME_HEIGHT - GROUND_Y);
  
  // Pits
  pits.forEach(pit => {
    const screenX = pit.x - camera.x;
    if (screenX > -pit.width && screenX < GAME_WIDTH) {
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(screenX, GROUND_Y, pit.width, GAME_HEIGHT - GROUND_Y);
      ctx.fillStyle = '#808080';
      for (let s = 0; s < pit.width; s += 15) {
        ctx.beginPath();
        ctx.moveTo(screenX + s, GAME_HEIGHT);
        ctx.lineTo(screenX + s + 7, GAME_HEIGHT - 20);
        ctx.lineTo(screenX + s + 14, GAME_HEIGHT);
        ctx.fill();
      }
    }
  });
  
  // Platforms
  platforms.forEach(plat => {
    const screenX = plat.x - camera.x;
    if (screenX > -plat.width && screenX < GAME_WIDTH) {
      ctx.fillStyle = '#8B4513';
      ctx.fillRect(screenX, plat.y, plat.width, plat.height);
      ctx.fillStyle = '#32CD32';
      ctx.fillRect(screenX, plat.y - 5, plat.width, 8);
    }
  });
  
  // Hearts
  hearts.forEach(heart => {
    if (heart.collected) return;
    const screenX = heart.x - camera.x;
    if (screenX > -30 && screenX < GAME_WIDTH) {
      ctx.fillStyle = '#FF0000';
      ctx.beginPath();
      ctx.moveTo(screenX + 15, heart.y + 5);
      ctx.bezierCurveTo(screenX + 15, heart.y, screenX, heart.y, screenX, heart.y + 10);
      ctx.bezierCurveTo(screenX, heart.y + 20, screenX + 15, heart.y + 25, screenX + 15, heart.y + 30);
      ctx.bezierCurveTo(screenX + 15, heart.y + 25, screenX + 30, heart.y + 20, screenX + 30, heart.y + 10);
      ctx.bezierCurveTo(screenX + 30, heart.y, screenX + 15, heart.y, screenX + 15, heart.y + 5);
      ctx.fill();
    }
  });
  
  // Enemies (goombas)
  enemies.forEach(enemy => {
    if (!enemy.alive) return;
    const screenX = enemy.x - camera.x;
    if (screenX > -60 && screenX < GAME_WIDTH + 60) {
      if (images.goomba) {
        ctx.save();
        if (enemy.direction < 0) {
          ctx.translate(screenX + 50, 0);
          ctx.scale(-1, 1);
          ctx.drawImage(images.goomba, 0, enemy.y - 10, 50, 60);
        } else {
          ctx.drawImage(images.goomba, screenX, enemy.y - 10, 50, 60);
        }
        ctx.restore();
      }
    }
  });
  
  // Projectiles
  projectiles.forEach(proj => {
    const screenX = proj.x - camera.x;
    ctx.fillStyle = '#800080';
    ctx.beginPath();
    ctx.arc(screenX, proj.y, 10, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#DDA0DD';
    ctx.beginPath();
    ctx.arc(screenX - proj.vx * 2, proj.y + 5, 3, 0, Math.PI * 2);
    ctx.fill();
  });
  
  // Spiders
  spiders.forEach(spider => {
    const screenX = spider.x - camera.x;
    if (screenX > -100 && screenX < GAME_WIDTH + 100) {
      // Web string
      ctx.strokeStyle = '#AAA';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(screenX + 40, 0);
      ctx.lineTo(screenX + 40, spider.y);
      ctx.stroke();
      
      if (images.boss) {
        ctx.drawImage(images.boss, screenX, spider.y, 80, 70);
      }
    }
  });
  
  // Foreground trees
  trees.forEach(tree => {
    if (tree.layer !== 'front') return;
    const screenX = tree.x - camera.x;
    if (screenX > -100 && screenX < GAME_WIDTH + 100) {
      ctx.fillStyle = '#5D4037';
      ctx.fillRect(screenX, GROUND_Y - tree.height, tree.trunkWidth, tree.height);
      ctx.fillStyle = '#2E7D32';
      ctx.beginPath();
      ctx.arc(screenX + tree.trunkWidth / 2, GROUND_Y - tree.height - tree.canopySize / 2, tree.canopySize, 0, Math.PI * 2);
      ctx.fill();
    }
  });
  
  // Player
  const playerScreenX = player.x - camera.x;
  if (!(player.invincible > 0 && Math.floor(player.invincible / 4) % 2 === 0)) {
    const playerImg = selectedCharacter === 'boy' ? images.boy : images.girl;
    if (playerImg) {
      ctx.save();
      const drawHeight = player.ducking ? PLAYER_DUCK_HEIGHT : PLAYER_HEIGHT;
      const drawY = player.ducking ? player.y + 20 : player.y;
      if (player.facing < 0) {
        ctx.translate(playerScreenX + PLAYER_WIDTH, 0);
        ctx.scale(-1, 1);
        ctx.drawImage(playerImg, 0, drawY, PLAYER_WIDTH, drawHeight);
      } else {
        ctx.drawImage(playerImg, playerScreenX, drawY, PLAYER_WIDTH, drawHeight);
      }
      ctx.restore();
    }
  }
  
  // HUD - Health
  ctx.fillStyle = 'rgba(0,0,0,0.7)';
  ctx.fillRect(10, 10, 180, 50);
  ctx.strokeStyle = '#FFD700';
  ctx.lineWidth = 2;
  ctx.strokeRect(10, 10, 180, 50);
  
  for (let i = 0; i < 5; i++) {
    ctx.fillStyle = i < health ? '#FF0000' : '#333';
    ctx.beginPath();
    const hx = 20 + i * 32;
    ctx.moveTo(hx + 12, 28);
    ctx.bezierCurveTo(hx + 12, 24, hx + 4, 22, hx + 4, 28);
    ctx.bezierCurveTo(hx + 4, 36, hx + 12, 40, hx + 12, 46);
    ctx.bezierCurveTo(hx + 12, 40, hx + 20, 36, hx + 20, 28);
    ctx.bezierCurveTo(hx + 20, 22, hx + 12, 24, hx + 12, 28);
    ctx.fill();
  }
  
  // HUD - Timer (prominent!)
  ctx.fillStyle = 'rgba(0,0,0,0.7)';
  ctx.fillRect(GAME_WIDTH / 2 - 60, 10, 120, 40);
  ctx.strokeStyle = timeRemaining <= 30 ? '#FF4444' : '#FFD700';
  ctx.lineWidth = 2;
  ctx.strokeRect(GAME_WIDTH / 2 - 60, 10, 120, 40);
  
  ctx.fillStyle = timeRemaining <= 30 ? '#FF4444' : '#FFF';
  ctx.font = 'bold 24px Arial';
  ctx.textAlign = 'center';
  ctx.fillText('‚è±Ô∏è ' + formatTime(timeRemaining), GAME_WIDTH / 2, 38);
  ctx.textAlign = 'left';
  
  // HUD - Score & Progress
  ctx.fillStyle = 'rgba(0,0,0,0.7)';
  ctx.fillRect(GAME_WIDTH - 160, 10, 150, 55);
  ctx.strokeStyle = '#FFD700';
  ctx.strokeRect(GAME_WIDTH - 160, 10, 150, 55);
  
  ctx.fillStyle = '#FFD700';
  ctx.font = 'bold 18px Arial';
  ctx.fillText('Score: ' + score, GAME_WIDTH - 150, 32);
  
  // Progress bar
  ctx.fillStyle = '#FFF';
  ctx.font = '12px Arial';
  ctx.fillText('Progress:', GAME_WIDTH - 150, 48);
  const progress = Math.min(1, player.x / LEVEL_LENGTH);
  ctx.fillStyle = '#333';
  ctx.fillRect(GAME_WIDTH - 90, 40, 70, 12);
  ctx.fillStyle = '#32CD32';
  ctx.fillRect(GAME_WIDTH - 90, 40, 70 * progress, 12);
  
  // Victory fireworks
  if (gameState === 'victory') {
    if (Math.random() < 0.15) {
      fireworks.push({
        x: Math.random() * GAME_WIDTH, y: GAME_HEIGHT,
        vy: -8 - Math.random() * 5,
        color: ['#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF'][Math.floor(Math.random() * 6)],
        exploded: false, particles: []
      });
    }
    
    fireworks = fireworks.filter(fw => {
      if (!fw.exploded) {
        fw.y += fw.vy;
        ctx.fillStyle = fw.color;
        ctx.beginPath();
        ctx.arc(fw.x, fw.y, 6, 0, Math.PI * 2);
        ctx.fill();
        if (fw.vy > -2) {
          fw.exploded = true;
          for (let i = 0; i < 30; i++) {
            fw.particles.push({ x: fw.x, y: fw.y, vx: (Math.random() - 0.5) * 12, vy: (Math.random() - 0.5) * 12, life: 60 });
          }
        }
      } else {
        fw.particles = fw.particles.filter(p => {
          p.x += p.vx; p.y += p.vy; p.vy += 0.15; p.life--;
          ctx.fillStyle = fw.color;
          ctx.globalAlpha = p.life / 60;
          ctx.beginPath();
          ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 1;
          return p.life > 0;
        });
        return fw.particles.length > 0;
      }
      return true;
    });
    
    // Victory text
    ctx.fillStyle = '#FFD700';
    ctx.font = 'bold 48px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('YOU WIN!', GAME_WIDTH / 2, GAME_HEIGHT / 2 - 20);
    ctx.font = 'bold 20px Arial';
    ctx.fillText('Click "Play Again" to continue', GAME_WIDTH / 2, GAME_HEIGHT / 2 + 20);
    ctx.textAlign = 'left';
    
    // Show victory screen after a delay
    setTimeout(() => {
      if (gameState === 'victory') {
        document.getElementById('gameCanvas').classList.add('hidden');
        document.getElementById('instructions').classList.add('hidden');
        document.getElementById('victoryScreen').classList.remove('hidden');
      }
    }, 3000);
  }
}

// Start loading
loadImages();
</script>
</body>
</html>
