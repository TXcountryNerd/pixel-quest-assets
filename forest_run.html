<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Forest Run Adventure</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      background: linear-gradient(to bottom, #1a472a, #2d5a3f);
      font-family: Arial, sans-serif;
      padding: 20px;
    }
    h1 {
      font-size: 2.5rem;
      background: linear-gradient(to right, #ffd700, #32cd32);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 20px;
    }
    #gameCanvas {
      border: 4px solid #daa520;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(50, 205, 50, 0.3);
    }
    .menu, .overlay {
      background: rgba(26, 71, 42, 0.95);
      padding: 30px;
      border-radius: 10px;
      border: 2px solid #ffd700;
      text-align: center;
      color: white;
    }
    .char-select { display: flex; gap: 30px; margin: 20px 0; }
    .char-btn {
      background: #2563eb;
      border: 2px solid #60a5fa;
      padding: 20px 30px;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.2s;
      color: white;
      font-weight: bold;
    }
    .char-btn:hover { transform: scale(1.05); background: #3b82f6; }
    .char-btn.girl { background: #7c3aed; border-color: #a78bfa; }
    .char-btn.girl:hover { background: #8b5cf6; }
    .char-btn img { width: 80px; height: 100px; object-fit: contain; display: block; margin: 0 auto 10px; }
    .controls { margin-top: 15px; padding-top: 15px; border-top: 1px solid #4a7c59; color: #9ca3af; font-size: 14px; }
    .controls span { color: #ffd700; }
    .tip { color: #4ade80; margin-top: 5px; }
    .warning { color: #f87171; }
    button {
      background: #16a34a;
      color: white;
      border: none;
      padding: 12px 30px;
      border-radius: 8px;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      margin: 5px;
      transition: all 0.2s;
    }
    button:hover { background: #22c55e; transform: scale(1.05); }
    button.secondary { background: #4b5563; }
    button.secondary:hover { background: #6b7280; }
    .hidden { display: none; }
    #instructions {
      margin-top: 15px;
      color: #d1d5db;
      font-size: 14px;
      background: rgba(0,0,0,0.3);
      padding: 10px 20px;
      border-radius: 8px;
    }
    .score-display {
      font-size: 1.5rem;
      color: #ffd700;
      margin: 10px 0;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    }
    .high-scores {
      background: rgba(0,0,0,0.4);
      padding: 15px;
      border-radius: 8px;
      margin-top: 15px;
    }
    .high-scores h3 { color: #ffd700; margin-bottom: 10px; }
    .high-scores p { color: #9ca3af; font-size: 14px; }
  </style>
</head>
<body>
  <h1>üå≤ Forest Run Adventure üå≤</h1>
  
  <div id="loadingScreen" class="menu">
    <h2>Loading...</h2>
    <div style="width: 250px; height: 20px; background: #374151; border-radius: 10px; overflow: hidden; margin: 20px auto;">
      <div id="loadingBar" style="width: 0%; height: 100%; background: linear-gradient(to right, #4ade80, #ffd700); transition: width 0.3s;"></div>
    </div>
    <p id="loadingText">0%</p>
  </div>
  
  <div id="selectScreen" class="menu hidden">
    <h2>Choose Your Hero!</h2>
    <div class="char-select">
      <button class="char-btn" onclick="selectCharacter('boy')">
        <img src="https://txcountrynerd.github.io/pixel-quest-assets/boy-transparent-2.png" alt="Boy">
        Boy Hero
      </button>
      <button class="char-btn girl" onclick="selectCharacter('girl')">
        <img src="https://txcountrynerd.github.io/pixel-quest-assets/girl-transparent-2.png" alt="Girl">
        Girl Hero
      </button>
    </div>
    <div class="high-scores">
      <h3>üèÜ Best Scores</h3>
      <div id="bestScores"><p>No scores yet - be the first!</p></div>
    </div>
    <div class="controls">
      <p><span>‚Üê ‚Üí</span> Move | <span>‚Üë</span> Jump | <span>‚Üì</span> Duck</p>
      <p class="tip">Jump on enemies to defeat them!</p>
      <p class="warning">‚è±Ô∏è Complete in 3 minutes or lose!</p>
      <p class="tip">üè† Reach the treehouse to win!</p>
    </div>
  </div>
  
  <canvas id="gameCanvas" class="hidden" width="800" height="500"></canvas>
  
  <div id="gameOverScreen" class="overlay hidden">
    <h2 style="color: #ef4444; font-size: 2.5rem; margin-bottom: 15px;">GAME OVER</h2>
    <p id="gameOverReason" style="color: #fca5a5; margin-bottom: 10px;"></p>
    <p class="score-display">Score: <span id="finalScore">0</span></p>
    <button onclick="restartLevel()">Try Again</button>
    <button class="secondary" onclick="backToSelect()">New Game</button>
  </div>
  
  <div id="instructions" class="hidden">
    <span style="color: #ffd700;">‚Üê ‚Üí</span> Move | 
    <span style="color: #ffd700;">‚Üë</span> Jump | 
    <span style="color: #ffd700;">‚Üì</span> Duck | 
    <span style="color: #4ade80;">Stomp enemies!</span> |
    <span style="color: #f87171;">‚è±Ô∏è Beat the clock!</span>
  </div>

<script>
// Game constants
const GAME_WIDTH = 800;
const GAME_HEIGHT = 500;
const GRAVITY = 0.6;
const JUMP_FORCE = -14;
const MOVE_SPEED = 5;
const PLAYER_WIDTH = 40;
const PLAYER_HEIGHT = 60;
const PLAYER_DUCK_HEIGHT = 35;
const GROUND_Y = 420;
const LEVEL_LENGTH = 8000;
const TIME_LIMIT = 180;

// Boss area constants
const BOSS_AREA_START = LEVEL_LENGTH - 800;
const TREEHOUSE_X = LEVEL_LENGTH - 150;
const TREEHOUSE_Y = 80;

// Sprite URLs
const SPRITE_URLS = {
  boy: 'https://txcountrynerd.github.io/pixel-quest-assets/boy-transparent-2.png',
  girl: 'https://txcountrynerd.github.io/pixel-quest-assets/girl-transparent-2.png',
  goomba: 'https://txcountrynerd.github.io/pixel-quest-assets/goomba-transparent-2.png',
  witch: 'https://txcountrynerd.github.io/pixel-quest-assets/witch-transparent-2.png',
  boss: 'https://txcountrynerd.github.io/pixel-quest-assets/boss-transparent-2.png'
};

// Game state
let gameState = 'loading';
let selectedCharacter = null;
let health = 5;
let score = 0;
let timeRemaining = TIME_LIMIT;
let timerInterval = null;
let images = {};
let bestScores = JSON.parse(localStorage.getItem('forestRunScores') || '[]');
let inCelebration = false;
let celebrationTimer = 0;

let player = { x: 50, y: GROUND_Y - PLAYER_HEIGHT, vx: 0, vy: 0, onGround: false, facing: 1, ducking: false, invincible: 0 };
let platforms = [];
let movingPlatforms = [];
let pits = [];
let trees = [];
let enemies = [];
let hearts = [];
let spiders = [];
let projectiles = [];
let clouds = [];
let camera = { x: 0 };
let keys = {};
let fireworks = [];

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Load images
function loadImages() {
  const spriteKeys = Object.keys(SPRITE_URLS);
  let loaded = 0;
  
  spriteKeys.forEach(key => {
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.onload = () => {
      images[key] = img;
      loaded++;
      updateLoading(loaded, spriteKeys.length);
    };
    img.onerror = () => {
      console.error('Failed to load:', key);
      loaded++;
      updateLoading(loaded, spriteKeys.length);
    };
    img.src = SPRITE_URLS[key];
  });
}

function updateLoading(loaded, total) {
  const pct = Math.floor((loaded / total) * 100);
  document.getElementById('loadingBar').style.width = pct + '%';
  document.getElementById('loadingText').textContent = pct + '%';
  if (loaded === total) {
    setTimeout(() => {
      document.getElementById('loadingScreen').classList.add('hidden');
      document.getElementById('selectScreen').classList.remove('hidden');
      displayBestScores();
      gameState = 'select';
    }, 300);
  }
}

function displayBestScores() {
  const container = document.getElementById('bestScores');
  if (bestScores.length === 0) {
    container.innerHTML = '<p>No scores yet - be the first!</p>';
  } else {
    const top5 = bestScores.slice(0, 5);
    container.innerHTML = top5.map((s, i) => 
      `<p style="color: ${i === 0 ? '#ffd700' : '#fff'};">${i + 1}. ${s.score} pts - ${s.character} (${formatTime(s.time)})</p>`
    ).join('');
  }
}

function formatTime(seconds) {
  const m = Math.floor(seconds / 60);
  const s = seconds % 60;
  return `${m}:${s.toString().padStart(2, '0')}`;
}

function saveScore(finalScore, timeUsed) {
  bestScores.push({ score: finalScore, character: selectedCharacter, time: timeUsed });
  bestScores.sort((a, b) => b.score - a.score);
  bestScores = bestScores.slice(0, 10);
  localStorage.setItem('forestRunScores', JSON.stringify(bestScores));
}

// Level generation
function generatePlatforms() {
  const p = [];
  let x = 200;
  while (x < BOSS_AREA_START - 200) {
    const y = 280 + Math.random() * 100;
    const width = 60 + Math.random() * 80;
    const hasGoomba = Math.random() > 0.7 && x > 500;
    p.push({ x, y, width, height: 20, hasGoomba });
    x += 150 + Math.random() * 200;
  }
  return p;
}

// Moving platforms throughout the level
function generateMovingPlatforms() {
  const mp = [];
  let x = 800;
  while (x < BOSS_AREA_START - 300) {
    if (Math.random() > 0.6) {
      const baseY = 250 + Math.random() * 100;
      mp.push({
        x, y: baseY, baseY,
        width: 70, height: 20,
        moveRange: 60 + Math.random() * 40,
        speed: 1 + Math.random() * 1.5,
        direction: Math.random() > 0.5 ? 1 : -1,
        type: 'vertical'
      });
    }
    x += 400 + Math.random() * 300;
  }
  return mp;
}

// Boss area platforms - ascending to treehouse
function generateBossAreaPlatforms() {
  const bp = [];
  const startX = BOSS_AREA_START + 50;
  
  // Ascending platforms leading to treehouse
  // Platform 1 - entry
  bp.push({ x: startX, y: 380, width: 80, height: 20, moving: false });
  
  // Platform 2 - moving
  bp.push({ x: startX + 100, y: 320, baseY: 320, width: 70, height: 20, moving: true, moveRange: 50, speed: 1.5, direction: 1 });
  
  // Platform 3 - static
  bp.push({ x: startX + 220, y: 270, width: 70, height: 20, moving: false });
  
  // Platform 4 - moving
  bp.push({ x: startX + 340, y: 220, baseY: 220, width: 70, height: 20, moving: true, moveRange: 60, speed: 2, direction: -1 });
  
  // Platform 5 - static
  bp.push({ x: startX + 460, y: 170, width: 70, height: 20, moving: false });
  
  // Platform 6 - moving, leads to treehouse
  bp.push({ x: startX + 560, y: 130, baseY: 130, width: 80, height: 20, moving: true, moveRange: 40, speed: 1.2, direction: 1 });
  
  return bp;
}

function generatePits() {
  const p = [];
  let x = 400;
  while (x < BOSS_AREA_START - 200) {
    const inSkillSection = (x > 2400 && x < 3000) || (x > 4900 && x < 5600);
    if (!inSkillSection) {
      const width = 80 + Math.random() * 60;
      p.push({ x, width });
    }
    x += 400 + Math.random() * 300;
  }
  
  // Boss area pit - spans most of the boss area
  p.push({ x: BOSS_AREA_START, width: 650, isBossPit: true });
  
  return p;
}

function generateSkillSections() {
  const sections = [];
  sections.push({ startX: 2500, pits: [
    { x: 2500, width: 100 },
    { x: 2650, width: 100 },
    { x: 2800, width: 100 }
  ], platforms: [
    { x: 2600, y: 380, width: 50, height: 20 },
    { x: 2750, y: 360, width: 50, height: 20 }
  ]});
  
  sections.push({ startX: 5000, pits: [
    { x: 5000, width: 120 },
    { x: 5180, width: 120 },
    { x: 5360, width: 120 }
  ], platforms: [
    { x: 5120, y: 370, width: 60, height: 20 },
    { x: 5300, y: 350, width: 60, height: 20 }
  ]});
  
  return sections;
}

function generateTrees() {
  const t = [];
  let x = 100;
  while (x < BOSS_AREA_START - 100) {
    t.push({
      x, height: 150 + Math.random() * 100,
      trunkWidth: 20 + Math.random() * 15,
      canopySize: 40 + Math.random() * 30,
      layer: Math.random() > 0.5 ? 'back' : 'front'
    });
    x += 80 + Math.random() * 120;
  }
  return t;
}

function generateEnemies() {
  const e = [];
  let x = 300;
  let id = 0;
  while (x < BOSS_AREA_START - 200) {
    const inSkillSection = (x > 2400 && x < 3000) || (x > 4900 && x < 5600);
    if (!inSkillSection) {
      e.push({
        id: id++, x, y: GROUND_Y - 50, startX: x,
        type: 'goomba', direction: 1, alive: true, attackCooldown: 0, onPlatform: false
      });
    }
    const spacing = x < 2000 ? 350 : x < 5000 ? 280 : 220;
    x += spacing + Math.random() * 150;
  }
  return e;
}

function generatePlatformEnemies(platforms) {
  const e = [];
  let id = 1000;
  platforms.forEach(plat => {
    if (plat.hasGoomba) {
      e.push({
        id: id++, x: plat.x + 10, y: plat.y - 50, startX: plat.x + 10,
        type: 'goomba', direction: 1, alive: true, attackCooldown: 0,
        onPlatform: true, platformX: plat.x, platformWidth: plat.width
      });
    }
  });
  return e;
}

function generateCloudsWithWitches() {
  const c = [];
  let x = 600;
  let id = 2000;
  while (x < BOSS_AREA_START - 200) {
    if (Math.random() > 0.5) {
      c.push({
        x, y: 150 + Math.random() * 100,
        width: 80, height: 30,
        witch: { id: id++, alive: true, attackCooldown: 0, direction: 1 }
      });
    }
    x += 500 + Math.random() * 400;
  }
  return c;
}

function generateHearts() {
  const h = [];
  let x = 600;
  while (x < BOSS_AREA_START - 200) {
    h.push({ x, y: 250 + Math.random() * 100, collected: false });
    x += 700 + Math.random() * 400;
  }
  return h;
}

// Spiders in the boss area - drop from top
function generateSpiders() {
  const s = [];
  const startX = BOSS_AREA_START + 80;
  for (let i = 0; i < 5; i++) {
    const baseY = 30 + (i % 2) * 20;
    s.push({
      x: startX + i * 130,
      y: baseY,
      baseY: baseY,
      maxY: 400, // Go all the way down
      direction: 1,
      speed: 2.5 + Math.random() * 2,
      phase: i * 0.7
    });
  }
  return s;
}

let skillSections = [];
let bossAreaPlatforms = [];

function initLevel() {
  player = { x: 50, y: GROUND_Y - PLAYER_HEIGHT, vx: 0, vy: 0, onGround: false, facing: 1, ducking: false, invincible: 0 };
  camera = { x: 0 };
  inCelebration = false;
  celebrationTimer = 0;
  
  skillSections = generateSkillSections();
  platforms = generatePlatforms();
  movingPlatforms = generateMovingPlatforms();
  bossAreaPlatforms = generateBossAreaPlatforms();
  
  skillSections.forEach(section => {
    section.platforms.forEach(p => platforms.push(p));
  });
  
  pits = generatePits();
  pits = pits.filter(pit => {
    if (pit.isBossPit) return true;
    for (const section of skillSections) {
      if (pit.x > section.startX - 200 && pit.x < section.startX + 600) return false;
    }
    return true;
  });
  
  skillSections.forEach(section => {
    section.pits.forEach(p => pits.push(p));
  });
  
  trees = generateTrees();
  enemies = generateEnemies();
  const platEnemies = generatePlatformEnemies(platforms);
  enemies = enemies.concat(platEnemies);
  
  clouds = generateCloudsWithWitches();
  hearts = generateHearts();
  spiders = generateSpiders();
  projectiles = [];
  fireworks = [];
  
  timeRemaining = TIME_LIMIT;
  if (timerInterval) clearInterval(timerInterval);
  timerInterval = setInterval(() => {
    if (gameState === 'playing' && !inCelebration) {
      timeRemaining--;
      if (timeRemaining <= 0) {
        timeOut();
      }
    }
  }, 1000);
}

function selectCharacter(char) {
  selectedCharacter = char;
  health = 5;
  score = 0;
  initLevel();
  document.getElementById('selectScreen').classList.add('hidden');
  document.getElementById('gameCanvas').classList.remove('hidden');
  document.getElementById('instructions').classList.remove('hidden');
  gameState = 'playing';
  requestAnimationFrame(gameLoop);
}

function restartLevel() {
  health = 5;
  score = 0;
  initLevel();
  document.getElementById('gameOverScreen').classList.add('hidden');
  document.getElementById('gameCanvas').classList.remove('hidden');
  document.getElementById('instructions').classList.remove('hidden');
  gameState = 'playing';
  requestAnimationFrame(gameLoop);
}

function backToSelect() {
  if (timerInterval) clearInterval(timerInterval);
  document.getElementById('gameOverScreen').classList.add('hidden');
  document.getElementById('gameCanvas').classList.add('hidden');
  document.getElementById('instructions').classList.add('hidden');
  document.getElementById('selectScreen').classList.remove('hidden');
  displayBestScores();
  score = 0;
  gameState = 'select';
}

function timeOut() {
  if (timerInterval) clearInterval(timerInterval);
  gameState = 'gameover';
  document.getElementById('gameOverReason').textContent = "‚è±Ô∏è Time's up!";
  document.getElementById('finalScore').textContent = score;
  document.getElementById('gameCanvas').classList.add('hidden');
  document.getElementById('instructions').classList.add('hidden');
  document.getElementById('gameOverScreen').classList.remove('hidden');
}

// Input handling
document.addEventListener('keydown', (e) => {
  keys[e.code] = true;
  if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) e.preventDefault();
});
document.addEventListener('keyup', (e) => { keys[e.code] = false; });

function gameLoop() {
  if (gameState !== 'playing') return;
  
  update();
  render();
  
  requestAnimationFrame(gameLoop);
}

function update() {
  if (gameState !== 'playing') return;
  
  // Handle celebration room
  if (inCelebration) {
    celebrationTimer++;
    // Spawn fireworks in celebration
    if (Math.random() < 0.1) {
      fireworks.push({
        x: 100 + Math.random() * 600,
        y: GAME_HEIGHT,
        vy: -6 - Math.random() * 4,
        color: ['#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF', '#FFA500'][Math.floor(Math.random() * 7)],
        exploded: false,
        particles: []
      });
    }
    return;
  }
  
  const currentHeight = player.ducking ? PLAYER_DUCK_HEIGHT : PLAYER_HEIGHT;
  
  // Player input
  if (keys['ArrowLeft']) { player.vx = -MOVE_SPEED; player.facing = -1; }
  else if (keys['ArrowRight']) { player.vx = MOVE_SPEED; player.facing = 1; }
  else { player.vx = 0; }
  
  player.ducking = keys['ArrowDown'] && player.onGround;
  
  if (keys['ArrowUp'] && player.onGround && !player.ducking) {
    player.vy = JUMP_FORCE;
    player.onGround = false;
  }
  
  // Physics
  player.vy += GRAVITY;
  player.x += player.vx;
  player.y += player.vy;
  
  // Update moving platforms
  movingPlatforms.forEach(mp => {
    mp.y += mp.direction * mp.speed;
    if (mp.y > mp.baseY + mp.moveRange || mp.y < mp.baseY - mp.moveRange) {
      mp.direction *= -1;
    }
  });
  
  // Update boss area platforms
  bossAreaPlatforms.forEach(bp => {
    if (bp.moving) {
      bp.y += bp.direction * bp.speed;
      if (bp.y > bp.baseY + bp.moveRange || bp.y < bp.baseY - bp.moveRange) {
        bp.direction *= -1;
      }
    }
  });
  
  // Check if over pit
  let overPit = false;
  for (const pit of pits) {
    if (player.x + PLAYER_WIDTH > pit.x && player.x < pit.x + pit.width) {
      overPit = true;
      break;
    }
  }
  
  // Ground collision (not in boss area)
  if (!overPit && player.y + currentHeight > GROUND_Y) {
    player.y = GROUND_Y - currentHeight;
    player.vy = 0;
    player.onGround = true;
  }
  
  // Fall into pit
  if (player.y > GAME_HEIGHT + 50) {
    health--;
    if (health <= 0) { endGame('Fell into the pit!'); return; }
    
    // Respawn - if in boss area, respawn at boss area start
    if (player.x >= BOSS_AREA_START) {
      player.x = BOSS_AREA_START - 100;
      player.y = GROUND_Y - PLAYER_HEIGHT;
    } else {
      player.x = Math.max(50, player.x - 200);
      player.y = GROUND_Y - PLAYER_HEIGHT;
    }
    player.vy = 0;
    player.invincible = 90;
  }
  
  // Static platform collision
  for (const plat of platforms) {
    if (player.x + PLAYER_WIDTH > plat.x && player.x < plat.x + plat.width) {
      if (player.y + currentHeight > plat.y && player.y + currentHeight < plat.y + plat.height + 15 && player.vy > 0) {
        player.y = plat.y - currentHeight;
        player.vy = 0;
        player.onGround = true;
      }
    }
  }
  
  // Moving platform collision
  for (const mp of movingPlatforms) {
    if (player.x + PLAYER_WIDTH > mp.x && player.x < mp.x + mp.width) {
      if (player.y + currentHeight > mp.y && player.y + currentHeight < mp.y + mp.height + 15 && player.vy > 0) {
        player.y = mp.y - currentHeight;
        player.vy = 0;
        player.onGround = true;
        // Move with platform
        if (mp.type === 'vertical') {
          player.y += mp.direction * mp.speed;
        }
      }
    }
  }
  
  // Boss area platform collision
  for (const bp of bossAreaPlatforms) {
    if (player.x + PLAYER_WIDTH > bp.x && player.x < bp.x + bp.width) {
      if (player.y + currentHeight > bp.y && player.y + currentHeight < bp.y + bp.height + 15 && player.vy > 0) {
        player.y = bp.y - currentHeight;
        player.vy = 0;
        player.onGround = true;
        // Move with platform if moving
        if (bp.moving) {
          player.y += bp.direction * bp.speed;
        }
      }
    }
  }
  
  // Boundaries
  player.x = Math.max(0, Math.min(LEVEL_LENGTH - PLAYER_WIDTH, player.x));
  if (player.invincible > 0) player.invincible--;
  
  // Camera
  camera.x = Math.max(0, Math.min(LEVEL_LENGTH - GAME_WIDTH, player.x - GAME_WIDTH / 3));
  
  // Enemy AI
  enemies.forEach(enemy => {
    if (!enemy.alive) return;
    
    if (enemy.onPlatform) {
      enemy.x += enemy.direction * 1.2;
      if (enemy.x < enemy.platformX || enemy.x > enemy.platformX + enemy.platformWidth - 40) {
        enemy.direction *= -1;
      }
    } else {
      enemy.x += enemy.direction * 1.5;
      if (Math.abs(enemy.x - enemy.startX) > 80) enemy.direction *= -1;
    }
    
    const enemyWidth = 50, enemyHeight = 50;
    if (player.x + PLAYER_WIDTH > enemy.x && player.x < enemy.x + enemyWidth) {
      if (player.vy > 0 && player.y + currentHeight > enemy.y && player.y + currentHeight < enemy.y + 25) {
        enemy.alive = false;
        player.vy = JUMP_FORCE * 0.6;
        score += 100;
      } else if (player.invincible <= 0 && player.y + currentHeight > enemy.y && player.y < enemy.y + enemyHeight) {
        health--;
        if (health <= 0) { endGame('Hit by a Goomba!'); return; }
        player.invincible = 90;
        player.vx = player.facing * -8;
      }
    }
  });
  
  // Cloud witches
  clouds.forEach(cloud => {
    if (!cloud.witch.alive) return;
    if (cloud.witch.attackCooldown <= 0) {
      const dist = player.x - cloud.x;
      if (Math.abs(dist) < 400 && Math.abs(dist) > 50) {
        projectiles.push({ x: cloud.x + 40, y: cloud.y + 50, vx: dist > 0 ? 3.5 : -3.5, vy: 1 });
        cloud.witch.attackCooldown = 120;
      }
    }
    if (cloud.witch.attackCooldown > 0) cloud.witch.attackCooldown--;
  });
  
  // Projectiles
  projectiles = projectiles.filter(proj => {
    proj.x += proj.vx;
    proj.y += proj.vy;
    proj.vy += 0.12;
    
    if (player.invincible <= 0 &&
        player.x + PLAYER_WIDTH > proj.x - 12 && player.x < proj.x + 12 &&
        player.y + currentHeight > proj.y - 12 && player.y < proj.y + 12) {
      health--;
      if (health <= 0) { endGame('Hit by a potion!'); return false; }
      player.invincible = 90;
      return false;
    }
    return proj.y < GAME_HEIGHT + 20 && proj.x > camera.x - 50 && proj.x < camera.x + GAME_WIDTH + 50;
  });
  
  // Hearts
  hearts.forEach(heart => {
    if (heart.collected) return;
    if (player.x + PLAYER_WIDTH > heart.x && player.x < heart.x + 30 &&
        player.y + currentHeight > heart.y && player.y < heart.y + 30) {
      heart.collected = true;
      health = Math.min(5, health + 1);
      score += 50;
    }
  });
  
  // Spiders
  spiders.forEach(spider => {
    spider.y += spider.direction * spider.speed;
    if (spider.y >= spider.maxY || spider.y <= spider.baseY) {
      spider.direction *= -1;
    }
    
    if (player.invincible <= 0 &&
        player.x + PLAYER_WIDTH > spider.x && player.x < spider.x + 80 &&
        player.y + currentHeight > spider.y && player.y < spider.y + 70) {
      health--;
      if (health <= 0) { endGame('Caught by a spider!'); return; }
      player.invincible = 90;
      player.vx = -8;
    }
  });
  
  // Check treehouse entry - victory!
  if (player.x > TREEHOUSE_X - 30 && player.x < TREEHOUSE_X + 80 &&
      player.y < TREEHOUSE_Y + 100 && player.y > TREEHOUSE_Y - 20) {
    enterCelebration();
  }
}

function enterCelebration() {
  inCelebration = true;
  celebrationTimer = 0;
  score += 500; // Bonus for reaching treehouse
  
  // Calculate final score
  const timeUsed = TIME_LIMIT - timeRemaining;
  const timeBonus = timeRemaining * 10;
  const totalScore = score + timeBonus;
  
  saveScore(totalScore, timeUsed);
}

function endGame(reason) {
  if (timerInterval) clearInterval(timerInterval);
  gameState = 'gameover';
  document.getElementById('gameOverReason').textContent = reason || '';
  document.getElementById('finalScore').textContent = score;
  document.getElementById('gameCanvas').classList.add('hidden');
  document.getElementById('instructions').classList.add('hidden');
  document.getElementById('gameOverScreen').classList.remove('hidden');
}

function render() {
  // If in celebration, render the treehouse interior
  if (inCelebration) {
    renderCelebration();
    return;
  }
  
  const currentHeight = player.ducking ? PLAYER_DUCK_HEIGHT : PLAYER_HEIGHT;
  
  // Sky gradient
  const skyGradient = ctx.createLinearGradient(0, 0, 0, GAME_HEIGHT);
  skyGradient.addColorStop(0, '#87CEEB');
  skyGradient.addColorStop(0.5, '#B0E0E6');
  skyGradient.addColorStop(1, '#98FB98');
  ctx.fillStyle = skyGradient;
  ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
  
  // Easter egg
  const easterEggX = 4000;
  const eggScreenX = easterEggX - camera.x;
  if (eggScreenX > -300 && eggScreenX < GAME_WIDTH + 100) {
    ctx.save();
    ctx.font = 'italic 16px Georgia';
    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
    ctx.fillText('‚ú® made by Sarah with AI ‚ú®', eggScreenX, 60);
    ctx.restore();
  }
  
  // Hills
  ctx.fillStyle = '#90EE90';
  for (let i = 0; i < 8; i++) {
    const hillX = (i * 250 - camera.x * 0.2) % (GAME_WIDTH + 400) - 200;
    ctx.beginPath();
    ctx.arc(hillX, GROUND_Y + 50, 120 + (i % 3) * 30, Math.PI, 0);
    ctx.fill();
  }
  
  // Background trees
  trees.forEach(tree => {
    if (tree.layer !== 'back') return;
    const screenX = tree.x - camera.x * 0.5;
    if (screenX > -100 && screenX < GAME_WIDTH + 100) {
      ctx.fillStyle = '#654321';
      ctx.fillRect(screenX, GROUND_Y - tree.height, tree.trunkWidth, tree.height);
      ctx.fillStyle = '#228B22';
      ctx.beginPath();
      ctx.arc(screenX + tree.trunkWidth / 2, GROUND_Y - tree.height - tree.canopySize / 2, tree.canopySize, 0, Math.PI * 2);
      ctx.fill();
    }
  });
  
  // Clouds with witches
  clouds.forEach(cloud => {
    const screenX = cloud.x - camera.x;
    if (screenX > -100 && screenX < GAME_WIDTH + 100) {
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(screenX + 20, cloud.y + 15, 25, 0, Math.PI * 2);
      ctx.arc(screenX + 50, cloud.y + 10, 30, 0, Math.PI * 2);
      ctx.arc(screenX + 80, cloud.y + 15, 25, 0, Math.PI * 2);
      ctx.fill();
      
      if (cloud.witch.alive && images.witch) {
        ctx.drawImage(images.witch, screenX + 25, cloud.y - 50, 45, 55);
      }
    }
  });
  
  // Treehouse at the end (goal!)
  const treehouseScreenX = TREEHOUSE_X - camera.x;
  if (treehouseScreenX > -150 && treehouseScreenX < GAME_WIDTH + 100) {
    // Large tree trunk
    ctx.fillStyle = '#5D4037';
    ctx.fillRect(treehouseScreenX + 30, TREEHOUSE_Y + 60, 50, 400);
    
    // Tree canopy behind house
    ctx.fillStyle = '#1B5E20';
    ctx.beginPath();
    ctx.arc(treehouseScreenX + 55, TREEHOUSE_Y - 20, 80, 0, Math.PI * 2);
    ctx.fill();
    
    // Treehouse structure
    ctx.fillStyle = '#8D6E63';
    ctx.fillRect(treehouseScreenX - 10, TREEHOUSE_Y + 20, 120, 80);
    
    // Roof
    ctx.fillStyle = '#5D4037';
    ctx.beginPath();
    ctx.moveTo(treehouseScreenX - 20, TREEHOUSE_Y + 20);
    ctx.lineTo(treehouseScreenX + 50, TREEHOUSE_Y - 20);
    ctx.lineTo(treehouseScreenX + 120, TREEHOUSE_Y + 20);
    ctx.fill();
    
    // Door
    ctx.fillStyle = '#3E2723';
    ctx.fillRect(treehouseScreenX + 40, TREEHOUSE_Y + 45, 30, 55);
    
    // Window
    ctx.fillStyle = '#FFEB3B';
    ctx.fillRect(treehouseScreenX + 5, TREEHOUSE_Y + 45, 25, 25);
    ctx.fillRect(treehouseScreenX + 80, TREEHOUSE_Y + 45, 25, 25);
    
    // Window frames
    ctx.strokeStyle = '#5D4037';
    ctx.lineWidth = 2;
    ctx.strokeRect(treehouseScreenX + 5, TREEHOUSE_Y + 45, 25, 25);
    ctx.strokeRect(treehouseScreenX + 80, TREEHOUSE_Y + 45, 25, 25);
    
    // "GOAL" sign
    ctx.fillStyle = '#FFD700';
    ctx.font = 'bold 14px Arial';
    ctx.fillText('üè† GOAL!', treehouseScreenX + 25, TREEHOUSE_Y + 10);
  }
  
  // Ground
  const groundGradient = ctx.createLinearGradient(0, GROUND_Y, 0, GAME_HEIGHT);
  groundGradient.addColorStop(0, '#228B22');
  groundGradient.addColorStop(0.1, '#32CD32');
  groundGradient.addColorStop(0.3, '#8B4513');
  groundGradient.addColorStop(1, '#654321');
  ctx.fillStyle = groundGradient;
  
  let lastX = 0;
  const sortedPits = [...pits].sort((a, b) => a.x - b.x);
  sortedPits.forEach(pit => {
    const startScreen = lastX - camera.x;
    ctx.fillRect(Math.max(0, startScreen), GROUND_Y, pit.x - lastX, GAME_HEIGHT - GROUND_Y);
    lastX = pit.x + pit.width;
  });
  ctx.fillRect(Math.max(0, lastX - camera.x), GROUND_Y, GAME_WIDTH, GAME_HEIGHT - GROUND_Y);
  
  // Pits
  pits.forEach(pit => {
    const screenX = pit.x - camera.x;
    if (screenX > -pit.width && screenX < GAME_WIDTH) {
      // Boss pit has lava!
      if (pit.isBossPit) {
        ctx.fillStyle = '#1a0a0a';
        ctx.fillRect(screenX, GROUND_Y, pit.width, GAME_HEIGHT - GROUND_Y);
        // Lava at bottom
        ctx.fillStyle = '#FF4500';
        ctx.fillRect(screenX, GAME_HEIGHT - 40, pit.width, 40);
        ctx.fillStyle = '#FF6600';
        for (let lx = 0; lx < pit.width; lx += 30) {
          ctx.beginPath();
          ctx.arc(screenX + lx + 15, GAME_HEIGHT - 40 + Math.sin(Date.now() / 200 + lx) * 5, 20, Math.PI, 0);
          ctx.fill();
        }
      } else {
        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(screenX, GROUND_Y, pit.width, GAME_HEIGHT - GROUND_Y);
        ctx.fillStyle = '#808080';
        for (let s = 0; s < pit.width; s += 15) {
          ctx.beginPath();
          ctx.moveTo(screenX + s, GAME_HEIGHT);
          ctx.lineTo(screenX + s + 7, GAME_HEIGHT - 20);
          ctx.lineTo(screenX + s + 14, GAME_HEIGHT);
          ctx.fill();
        }
      }
    }
  });
  
  // Static platforms
  platforms.forEach(plat => {
    const screenX = plat.x - camera.x;
    if (screenX > -plat.width && screenX < GAME_WIDTH) {
      ctx.fillStyle = '#8B4513';
      ctx.fillRect(screenX, plat.y, plat.width, plat.height);
      ctx.fillStyle = '#32CD32';
      ctx.fillRect(screenX, plat.y - 5, plat.width, 8);
    }
  });
  
  // Moving platforms
  movingPlatforms.forEach(mp => {
    const screenX = mp.x - camera.x;
    if (screenX > -mp.width && screenX < GAME_WIDTH) {
      // Platform with glow effect
      ctx.fillStyle = '#6B4226';
      ctx.fillRect(screenX, mp.y, mp.width, mp.height);
      ctx.fillStyle = '#90EE90';
      ctx.fillRect(screenX, mp.y - 5, mp.width, 8);
      // Arrow indicators
      ctx.fillStyle = '#FFD700';
      ctx.font = '12px Arial';
      ctx.fillText('‚Üï', screenX + mp.width / 2 - 5, mp.y + 15);
    }
  });
  
  // Boss area platforms
  bossAreaPlatforms.forEach(bp => {
    const screenX = bp.x - camera.x;
    if (screenX > -bp.width && screenX < GAME_WIDTH) {
      if (bp.moving) {
        ctx.fillStyle = '#8B5A2B';
        ctx.fillRect(screenX, bp.y, bp.width, bp.height);
        ctx.fillStyle = '#98FB98';
        ctx.fillRect(screenX, bp.y - 5, bp.width, 8);
        ctx.fillStyle = '#FFD700';
        ctx.font = '10px Arial';
        ctx.fillText('‚Üï', screenX + bp.width / 2 - 4, bp.y + 14);
      } else {
        ctx.fillStyle = '#8B4513';
        ctx.fillRect(screenX, bp.y, bp.width, bp.height);
        ctx.fillStyle = '#32CD32';
        ctx.fillRect(screenX, bp.y - 5, bp.width, 8);
      }
    }
  });
  
  // Hearts
  hearts.forEach(heart => {
    if (heart.collected) return;
    const screenX = heart.x - camera.x;
    if (screenX > -30 && screenX < GAME_WIDTH) {
      ctx.fillStyle = '#FF0000';
      ctx.beginPath();
      ctx.moveTo(screenX + 15, heart.y + 5);
      ctx.bezierCurveTo(screenX + 15, heart.y, screenX, heart.y, screenX, heart.y + 10);
      ctx.bezierCurveTo(screenX, heart.y + 20, screenX + 15, heart.y + 25, screenX + 15, heart.y + 30);
      ctx.bezierCurveTo(screenX + 15, heart.y + 25, screenX + 30, heart.y + 20, screenX + 30, heart.y + 10);
      ctx.bezierCurveTo(screenX + 30, heart.y, screenX + 15, heart.y, screenX + 15, heart.y + 5);
      ctx.fill();
    }
  });
  
  // Enemies
  enemies.forEach(enemy => {
    if (!enemy.alive) return;
    const screenX = enemy.x - camera.x;
    if (screenX > -60 && screenX < GAME_WIDTH + 60) {
      if (images.goomba) {
        ctx.save();
        if (enemy.direction < 0) {
          ctx.translate(screenX + 50, 0);
          ctx.scale(-1, 1);
          ctx.drawImage(images.goomba, 0, enemy.y - 10, 50, 60);
        } else {
          ctx.drawImage(images.goomba, screenX, enemy.y - 10, 50, 60);
        }
        ctx.restore();
      }
    }
  });
  
  // Projectiles
  projectiles.forEach(proj => {
    const screenX = proj.x - camera.x;
    ctx.fillStyle = '#800080';
    ctx.beginPath();
    ctx.arc(screenX, proj.y, 10, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#DDA0DD';
    ctx.beginPath();
    ctx.arc(screenX - proj.vx * 2, proj.y + 5, 3, 0, Math.PI * 2);
    ctx.fill();
  });
  
  // Spiders
  spiders.forEach(spider => {
    const screenX = spider.x - camera.x;
    if (screenX > -100 && screenX < GAME_WIDTH + 100) {
      ctx.strokeStyle = '#AAA';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(screenX + 40, 0);
      ctx.lineTo(screenX + 40, spider.y);
      ctx.stroke();
      
      if (images.boss) {
        ctx.drawImage(images.boss, screenX, spider.y, 80, 70);
      }
    }
  });
  
  // Foreground trees
  trees.forEach(tree => {
    if (tree.layer !== 'front') return;
    const screenX = tree.x - camera.x;
    if (screenX > -100 && screenX < GAME_WIDTH + 100) {
      ctx.fillStyle = '#5D4037';
      ctx.fillRect(screenX, GROUND_Y - tree.height, tree.trunkWidth, tree.height);
      ctx.fillStyle = '#2E7D32';
      ctx.beginPath();
      ctx.arc(screenX + tree.trunkWidth / 2, GROUND_Y - tree.height - tree.canopySize / 2, tree.canopySize, 0, Math.PI * 2);
      ctx.fill();
    }
  });
  
  // Player
  const playerScreenX = player.x - camera.x;
  if (!(player.invincible > 0 && Math.floor(player.invincible / 4) % 2 === 0)) {
    const playerImg = selectedCharacter === 'boy' ? images.boy : images.girl;
    if (playerImg) {
      ctx.save();
      const drawHeight = player.ducking ? PLAYER_DUCK_HEIGHT : PLAYER_HEIGHT;
      const drawY = player.ducking ? player.y + 20 : player.y;
      if (player.facing < 0) {
        ctx.translate(playerScreenX + PLAYER_WIDTH, 0);
        ctx.scale(-1, 1);
        ctx.drawImage(playerImg, 0, drawY, PLAYER_WIDTH, drawHeight);
      } else {
        ctx.drawImage(playerImg, playerScreenX, drawY, PLAYER_WIDTH, drawHeight);
      }
      ctx.restore();
    }
  }
  
  // HUD
  renderHUD();
}

function renderCelebration() {
  // Treehouse interior background - warm wood tones
  const woodGradient = ctx.createLinearGradient(0, 0, 0, GAME_HEIGHT);
  woodGradient.addColorStop(0, '#8B5A2B');
  woodGradient.addColorStop(0.5, '#A0522D');
  woodGradient.addColorStop(1, '#6B4226');
  ctx.fillStyle = woodGradient;
  ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
  
  // Wood plank lines on walls
  ctx.strokeStyle = '#5D4037';
  ctx.lineWidth = 2;
  for (let y = 0; y < GAME_HEIGHT; y += 40) {
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(GAME_WIDTH, y);
    ctx.stroke();
  }
  
  // Wood grain details
  ctx.strokeStyle = 'rgba(93, 64, 55, 0.3)';
  ctx.lineWidth = 1;
  for (let i = 0; i < 20; i++) {
    const x = 50 + i * 40;
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.bezierCurveTo(x + 10, GAME_HEIGHT / 3, x - 10, GAME_HEIGHT * 2 / 3, x, GAME_HEIGHT);
    ctx.stroke();
  }
  
  // Floor
  ctx.fillStyle = '#4E342E';
  ctx.fillRect(0, GAME_HEIGHT - 80, GAME_WIDTH, 80);
  
  // Floor boards
  ctx.strokeStyle = '#3E2723';
  ctx.lineWidth = 2;
  for (let x = 0; x < GAME_WIDTH; x += 60) {
    ctx.beginPath();
    ctx.moveTo(x, GAME_HEIGHT - 80);
    ctx.lineTo(x, GAME_HEIGHT);
    ctx.stroke();
  }
  
  // Window on left
  ctx.fillStyle = '#87CEEB';
  ctx.fillRect(50, 100, 120, 100);
  ctx.strokeStyle = '#5D4037';
  ctx.lineWidth = 8;
  ctx.strokeRect(50, 100, 120, 100);
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.moveTo(110, 100);
  ctx.lineTo(110, 200);
  ctx.moveTo(50, 150);
  ctx.lineTo(170, 150);
  ctx.stroke();
  
  // Curtains
  ctx.fillStyle = '#C62828';
  ctx.fillRect(40, 85, 30, 130);
  ctx.fillRect(150, 85, 30, 130);
  
  // Window on right
  ctx.fillStyle = '#87CEEB';
  ctx.fillRect(GAME_WIDTH - 170, 100, 120, 100);
  ctx.strokeStyle = '#5D4037';
  ctx.lineWidth = 8;
  ctx.strokeRect(GAME_WIDTH - 170, 100, 120, 100);
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.moveTo(GAME_WIDTH - 110, 100);
  ctx.lineTo(GAME_WIDTH - 110, 200);
  ctx.moveTo(GAME_WIDTH - 170, 150);
  ctx.lineTo(GAME_WIDTH - 50, 150);
  ctx.stroke();
  
  // Curtains
  ctx.fillStyle = '#C62828';
  ctx.fillRect(GAME_WIDTH - 180, 85, 30, 130);
  ctx.fillRect(GAME_WIDTH - 70, 85, 30, 130);
  
  // Decorative banner
  ctx.fillStyle = '#FFD700';
  ctx.beginPath();
  ctx.moveTo(200, 50);
  ctx.lineTo(600, 50);
  ctx.lineTo(620, 70);
  ctx.lineTo(600, 90);
  ctx.lineTo(200, 90);
  ctx.lineTo(180, 70);
  ctx.closePath();
  ctx.fill();
  ctx.strokeStyle = '#B8860B';
  ctx.lineWidth = 3;
  ctx.stroke();
  
  // Hanging string
  ctx.strokeStyle = '#8B4513';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(200, 50);
  ctx.lineTo(180, 20);
  ctx.moveTo(600, 50);
  ctx.lineTo(620, 20);
  ctx.stroke();
  
  // Bookshelf
  ctx.fillStyle = '#5D4037';
  ctx.fillRect(250, 250, 100, 120);
  ctx.fillStyle = '#3E2723';
  ctx.fillRect(255, 260, 90, 5);
  ctx.fillRect(255, 300, 90, 5);
  ctx.fillRect(255, 340, 90, 5);
  
  // Books
  const bookColors = ['#E53935', '#1E88E5', '#43A047', '#FB8C00', '#8E24AA'];
  for (let row = 0; row < 3; row++) {
    for (let b = 0; b < 4; b++) {
      ctx.fillStyle = bookColors[(row + b) % bookColors.length];
      ctx.fillRect(260 + b * 20, 265 + row * 40, 15, 30);
    }
  }
  
  // Cozy rug
  ctx.fillStyle = '#B71C1C';
  ctx.beginPath();
  ctx.ellipse(GAME_WIDTH / 2, GAME_HEIGHT - 50, 150, 40, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#880E0E';
  ctx.beginPath();
  ctx.ellipse(GAME_WIDTH / 2, GAME_HEIGHT - 50, 120, 30, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#FFD700';
  ctx.beginPath();
  ctx.ellipse(GAME_WIDTH / 2, GAME_HEIGHT - 50, 80, 20, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Character standing on rug
  const playerImg = selectedCharacter === 'boy' ? images.boy : images.girl;
  if (playerImg) {
    ctx.drawImage(playerImg, GAME_WIDTH / 2 - 30, GAME_HEIGHT - 140, 60, 90);
  }
  
  // Lanterns
  ctx.fillStyle = '#FFA000';
  ctx.beginPath();
  ctx.arc(100, 300, 20, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#FFECB3';
  ctx.beginPath();
  ctx.arc(100, 300, 12, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.fillStyle = '#FFA000';
  ctx.beginPath();
  ctx.arc(GAME_WIDTH - 100, 300, 20, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#FFECB3';
  ctx.beginPath();
  ctx.arc(GAME_WIDTH - 100, 300, 12, 0, Math.PI * 2);
  ctx.fill();
  
  // Update and draw fireworks
  fireworks = fireworks.filter(fw => {
    if (!fw.exploded) {
      fw.y += fw.vy;
      ctx.fillStyle = fw.color;
      ctx.beginPath();
      ctx.arc(fw.x, fw.y, 5, 0, Math.PI * 2);
      ctx.fill();
      if (fw.vy > -2) {
        fw.exploded = true;
        for (let i = 0; i < 25; i++) {
          fw.particles.push({
            x: fw.x, y: fw.y,
            vx: (Math.random() - 0.5) * 10,
            vy: (Math.random() - 0.5) * 10,
            life: 50
          });
        }
      }
    } else {
      fw.particles = fw.particles.filter(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.1;
        p.life--;
        ctx.fillStyle = fw.color;
        ctx.globalAlpha = p.life / 50;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
        return p.life > 0;
      });
      return fw.particles.length > 0;
    }
    return true;
  });
  
  // Victory text
  ctx.fillStyle = '#FFD700';
  ctx.font = 'bold 48px Georgia';
  ctx.textAlign = 'center';
  ctx.shadowColor = '#000';
  ctx.shadowBlur = 10;
  ctx.fillText('üéâ VICTORY! üéâ', GAME_WIDTH / 2, 75);
  ctx.shadowBlur = 0;
  
  // Score display
  const timeUsed = TIME_LIMIT - timeRemaining;
  const timeBonus = timeRemaining * 10;
  const totalScore = score + timeBonus;
  
  ctx.fillStyle = '#FFF';
  ctx.font = 'bold 24px Arial';
  ctx.fillText('You reached the treehouse!', GAME_WIDTH / 2, 130);
  
  ctx.font = '20px Arial';
  ctx.fillStyle = '#90EE90';
  ctx.fillText('Base Score: ' + score, GAME_WIDTH / 2, 170);
  ctx.fillText('Time Bonus: +' + timeBonus, GAME_WIDTH / 2, 195);
  
  ctx.font = 'bold 28px Arial';
  ctx.fillStyle = '#FFD700';
  ctx.fillText('TOTAL: ' + totalScore, GAME_WIDTH / 2, 235);
  
  ctx.textAlign = 'left';
  
  // Play again button hint
  if (celebrationTimer > 120) {
    ctx.fillStyle = '#FFF';
    ctx.font = '18px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Press SPACE or click to play again', GAME_WIDTH / 2, GAME_HEIGHT - 15);
    ctx.textAlign = 'left';
  }
}

// Add click/space handler for celebration
document.addEventListener('click', () => {
  if (inCelebration && celebrationTimer > 120) {
    backToSelect();
  }
});
document.addEventListener('keydown', (e) => {
  if (e.code === 'Space' && inCelebration && celebrationTimer > 120) {
    backToSelect();
  }
});

function renderHUD() {
  // Health
  ctx.fillStyle = 'rgba(0,0,0,0.7)';
  ctx.fillRect(10, 10, 180, 50);
  ctx.strokeStyle = '#FFD700';
  ctx.lineWidth = 2;
  ctx.strokeRect(10, 10, 180, 50);
  
  for (let i = 0; i < 5; i++) {
    ctx.fillStyle = i < health ? '#FF0000' : '#333';
    ctx.beginPath();
    const hx = 20 + i * 32;
    ctx.moveTo(hx + 12, 28);
    ctx.bezierCurveTo(hx + 12, 24, hx + 4, 22, hx + 4, 28);
    ctx.bezierCurveTo(hx + 4, 36, hx + 12, 40, hx + 12, 46);
    ctx.bezierCurveTo(hx + 12, 40, hx + 20, 36, hx + 20, 28);
    ctx.bezierCurveTo(hx + 20, 22, hx + 12, 24, hx + 12, 28);
    ctx.fill();
  }
  
  // Timer
  ctx.fillStyle = 'rgba(0,0,0,0.7)';
  ctx.fillRect(GAME_WIDTH / 2 - 60, 10, 120, 40);
  ctx.strokeStyle = timeRemaining <= 30 ? '#FF4444' : '#FFD700';
  ctx.lineWidth = 2;
  ctx.strokeRect(GAME_WIDTH / 2 - 60, 10, 120, 40);
  
  ctx.fillStyle = timeRemaining <= 30 ? '#FF4444' : '#FFF';
  ctx.font = 'bold 24px Arial';
  ctx.textAlign = 'center';
  ctx.fillText('‚è±Ô∏è ' + formatTime(timeRemaining), GAME_WIDTH / 2, 38);
  ctx.textAlign = 'left';
  
  // Score & Progress
  ctx.fillStyle = 'rgba(0,0,0,0.7)';
  ctx.fillRect(GAME_WIDTH - 160, 10, 150, 55);
  ctx.strokeStyle = '#FFD700';
  ctx.strokeRect(GAME_WIDTH - 160, 10, 150, 55);
  
  ctx.fillStyle = '#FFD700';
  ctx.font = 'bold 18px Arial';
  ctx.fillText('Score: ' + score, GAME_WIDTH - 150, 32);
  
  ctx.fillStyle = '#FFF';
  ctx.font = '12px Arial';
  ctx.fillText('Progress:', GAME_WIDTH - 150, 48);
  const progress = Math.min(1, player.x / LEVEL_LENGTH);
  ctx.fillStyle = '#333';
  ctx.fillRect(GAME_WIDTH - 90, 40, 70, 12);
  ctx.fillStyle = '#32CD32';
  ctx.fillRect(GAME_WIDTH - 90, 40, 70 * progress, 12);
}

// Start loading
loadImages();
</script>
</body>
</html>
